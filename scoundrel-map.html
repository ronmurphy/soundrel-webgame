<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoundrel - A Rogue-like Card Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        :root {
            --parchment: #f4e8d0;
            --dark-wood: #2a1810;
            --burnt-orange: #d4621f;
            --blood-red: #8b0000;
            --gold: #d4af37;
            --shadow: rgba(0, 0, 0, 0.5);
            --card-bg: #1a1a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }

        body {
            font-family: 'Crimson Text', serif;
            background: linear-gradient(135deg, #1a0e08 0%, #2a1810 50%, #1a0e08 100%);
            background-attachment: fixed;
            color: var(--parchment);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,.03) 2px, rgba(0,0,0,.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,0,0,.03) 2px, rgba(0,0,0,.03) 4px);
            pointer-events: none;
            opacity: 0.3;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            color: var(--gold);
            text-shadow: 
                2px 2px 0 var(--blood-red),
                4px 4px 8px var(--shadow);
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-style: italic;
            font-size: 1.2rem;
            color: var(--burnt-orange);
            opacity: 0.9;
        }

        .game-board {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 2rem;
            margin-bottom: 2rem;
            animation: fadeIn 1s ease-out 0.3s backwards;
        }

        .stats-panel {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.9), rgba(26, 14, 8, 0.9));
            border: 3px solid var(--burnt-orange);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px var(--shadow);
            backdrop-filter: blur(10px);
        }

        .stat-item {
            margin-bottom: 1.5rem;
        }

        .stat-label {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: var(--parchment);
            text-shadow: 0 2px 4px var(--shadow);
        }

        .health-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--burnt-orange);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            margin-top: 0.5rem;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--blood-red), var(--burnt-orange));
            transition: width 0.5s ease-out;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .weapon-display {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            min-height: 100px;
        }

        .weapon-card {
            position: relative;
        }

        .play-area {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.6), rgba(26, 14, 8, 0.6));
            border: 4px solid var(--burnt-orange);
            border-radius: 16px;
            padding: 2rem;
            min-height: 500px;
            box-shadow: 
                0 8px 32px var(--shadow),
                inset 0 0 60px rgba(0, 0, 0, 0.3);
        }

        .room {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            aspect-ratio: 2.5/4;
            background: var(--card-bg);
            border: 3px solid var(--gold);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            transform-style: preserve-3d;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .card:hover:not(.disabled) {
            transform: translateY(-12px) scale(1.05);
            box-shadow: 
                0 12px 24px var(--shadow),
                0 0 30px rgba(212, 175, 55, 0.4);
            border-color: var(--parchment);
        }

        .card.selected {
            animation: cardFlip 0.6s ease-out;
        }

        @keyframes cardFlip {
            0% {
                transform: rotateY(0deg) scale(1);
            }
            50% {
                transform: rotateY(90deg) scale(1.1);
            }
            100% {
                transform: rotateY(0deg) scale(1);
            }
        }

        .card.monster:hover:not(.disabled) {
            box-shadow: 
                0 12px 24px var(--shadow),
                0 0 40px rgba(139, 0, 0, 0.6);
        }

        .card.weapon:hover:not(.disabled) {
            box-shadow: 
                0 12px 24px var(--shadow),
                0 0 40px rgba(212, 175, 55, 0.6);
        }

        .card.potion:hover:not(.disabled) {
            box-shadow: 
                0 12px 24px var(--shadow),
                0 0 40px rgba(0, 170, 0, 0.6);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-inner {
            width: 100%;
            height: 100%;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .card-suit {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .card-value {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 2px 4px var(--shadow);
        }

        .card-type {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        .card.monster {
            border-color: #8b0000;
            background: linear-gradient(145deg, #1a0000, #2a0a0a);
        }

        .card.weapon {
            border-color: #4a4a4a;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
        }

        .card.potion {
            border-color: #00aa00;
            background: linear-gradient(145deg, #002200, #003300);
        }

        .card-back {
            background: linear-gradient(145deg, var(--burnt-orange), var(--blood-red));
            border: 3px solid var(--gold);
            border-radius: 12px;
            aspect-ratio: 2.5/4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
            text-shadow: 0 2px 4px var(--shadow);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            padding: 1rem 2rem;
            background: linear-gradient(145deg, var(--burnt-orange), var(--blood-red));
            color: var(--parchment);
            border: 3px solid var(--gold);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            box-shadow: 0 4px 12px var(--shadow);
            font-weight: 600;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow);
            background: linear-gradient(145deg, var(--gold), var(--burnt-orange));
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .message {
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
            font-size: 1.1rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: messageSlide 0.3s ease-out;
        }

        .map-container {
            margin-top: 1.5rem;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--burnt-orange);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mapCanvas {
            border-radius: 4px;
            cursor: pointer;
        }

        .damage-indicator {
            position: fixed;
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--blood-red);
            text-shadow: 0 0 10px var(--blood-red);
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
        }

        .heal-indicator {
            position: fixed;
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            font-weight: 700;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
        }

        .monster-stack {
            position: absolute;
            top: 0;
            right: -10px;
            background: rgba(139, 0, 0, 0.9);
            border: 2px solid var(--blood-red);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.5);
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pulse {
            animation: pulse 0.3s ease-in-out;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.5s ease-out;
        }

        .game-over-content {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.95), rgba(26, 14, 8, 0.95));
            border: 4px solid var(--gold);
            border-radius: 16px;
            padding: 3rem;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 16px 48px var(--shadow);
        }

        .game-over-content h2 {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px var(--shadow);
        }

        .helper-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            animation: fadeIn 0.3s ease-out;
        }

        .helper-modal-content {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.95), rgba(26, 14, 8, 0.95));
            border: 4px solid var(--gold);
            border-radius: 16px;
            padding: 2rem;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 16px 48px var(--shadow);
        }

        .helper-modal-content h3 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
        }

        .helper-card-display {
            margin: 1.5rem 0;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .helper-card {
            background: var(--card-bg);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 1.5rem;
            min-width: 150px;
        }

        .helper-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .score {
            font-size: 2rem;
            margin-bottom: 2rem;
            color: var(--parchment);
        }

        @media (max-width: 1024px) {
            .game-board {
                grid-template-columns: 1fr;
            }

            .room {
                grid-template-columns: repeat(2, 1fr);
            }

            h1 {
                font-size: 2.5rem;
            }
        }

        .instructions {
            background: rgba(42, 24, 16, 0.8);
            border: 2px solid var(--burnt-orange);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .instructions h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 1rem;
        }

        .instructions ul {
            margin-left: 1.5rem;
        }

        .instructions li {
            margin-bottom: 0.5rem;
        }

        .dungeon-info {
            font-size: 1rem;
            color: var(--burnt-orange);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="container">
        <header>
            <h1>⚔ SCOUNDREL ⚔</h1>
            <p class="subtitle">A Rogue-like Card Game</p>
        </header>

        <div class="instructions" id="instructions">
            <h3>How to Play:</h3>
            <ul>
                <li><strong>♣♠ Monsters</strong> deal damage equal to their value (J=11, Q=12, K=13, A=14)</li>
                <li><strong>♦ Weapons</strong> reduce monster damage. Once used, can only fight weaker monsters</li>
                <li><strong>♥ Potions</strong> restore health (one per turn, max 20 HP)</li>
                <li>Choose 3 of 4 cards each turn. The 4th carries to next room</li>
                <li>You can skip a room, but not two in a row</li>
                <li>Survive the dungeon or die trying!</li>
            </ul>
        </div>

        <div class="game-board">
            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-label">Health</div>
                    <div class="stat-value" id="health">20</div>
                    <div class="health-bar">
                        <div class="health-fill" id="healthBar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Cards in Dungeon</div>
                    <div class="stat-value" id="deckCount">44</div>
                    <div class="dungeon-info">Start: 44 cards</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Potions Used</div>
                    <div class="stat-value" id="potionCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Equipped Weapon</div>
                    <div class="weapon-display" id="weaponDisplay">
                        <div style="text-align: center; opacity: 0.5;">No weapon</div>
                    </div>
                </div>
            </div>

            <div class="play-area">
                <div class="room" id="room"></div>
                <div class="controls">
                    <button id="avoidBtn">Avoid Room</button>
                    <button id="newGameBtn">New Game</button>
                </div>
                <div class="message" id="message">Click "New Game" to begin your descent into the dungeon...</div>
                <div class="map-container">
                    <canvas id="mapCanvas"></canvas>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-label">Cards Chosen</div>
                    <div class="stat-value" id="cardsChosen">0 / 3</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Monsters Slain</div>
                    <div class="stat-value" id="monstersSlain">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Rooms Cleared</div>
                    <div class="stat-value" id="roomsCleared">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Rooms Avoided</div>
                    <div class="stat-value" id="roomsAvoided">0</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            health: 20,
            maxHealth: 20,
            deck: [],
            room: [],
            cardsChosen: 0,
            weapon: null,
            weaponLastMonster: Infinity,
            lastRoomAvoided: false,
            potionUsedThisTurn: false,
            monstersSlain: 0,
            roomsCleared: 0,
            roomsAvoided: 0,
            potionsUsed: 0,
            gameOver: false,
            dungeonMap: null,
            currentRoomIndex: 0,
            playerPosition: null,
            redCardHelpers: [] // Store red face cards for helpers
        };

        // Card creation
        function createDeck() {
            const deck = [];
            const suits = {
                clubs: '♣',
                spades: '♠',
                diamonds: '♦',
                hearts: '♥'
            };

            // Monster names by value
            const monsterNames = {
                2: 'Rat',
                3: 'Spider',
                4: 'Goblin',
                5: 'Skeleton',
                6: 'Orc',
                7: 'Warg',
                8: 'Troll',
                9: 'Wraith',
                10: 'Chimera',
                11: 'Dragon',
                12: 'Titan',
                13: 'Roc',
                14: 'Cyclops'
            };

            // Monsters: all clubs and spades
            ['clubs', 'spades'].forEach(suit => {
                for (let value = 2; value <= 14; value++) {
                    deck.push({
                        suit: suits[suit],
                        value: value,
                        type: 'monster',
                        display: getCardDisplay(value),
                        name: monsterNames[value]
                    });
                }
            });

            // Weapon names by value
            const weaponNames = {
                2: 'Stick',
                3: 'Dagger',
                4: 'Short Sword',
                5: 'Mace',
                6: 'Battle Axe',
                7: 'Longsword',
                8: 'War Hammer',
                9: 'Greatsword',
                10: 'Halberd'
            };

            // Weapons: diamonds 2-10
            for (let value = 2; value <= 10; value++) {
                deck.push({
                    suit: suits.diamonds,
                    value: value,
                    type: 'weapon',
                    display: getCardDisplay(value),
                    name: weaponNames[value]
                });
            }

            // Potion names by value
            const potionNames = {
                2: 'Weak Tonic',
                3: 'Minor Elixir',
                4: 'Healing Brew',
                5: 'Health Potion',
                6: 'Greater Potion',
                7: 'Vitality Draught',
                8: 'Major Elixir',
                9: 'Superior Brew',
                10: 'Legendary Potion'
            };

            // Potions: hearts 2-10
            for (let value = 2; value <= 10; value++) {
                deck.push({
                    suit: suits.hearts,
                    value: value,
                    type: 'potion',
                    display: getCardDisplay(value),
                    name: potionNames[value]
                });
            }

            return shuffle(deck);
        }

        function getCardDisplay(value) {
            const faces = { 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
            return faces[value] || value.toString();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Dungeon Map Generation
        function generateDungeonMap() {
            const rooms = [];
            const numRooms = 16;
            
            // Create rooms in a grid pattern with branching
            const grid = [
                [0, 1, 2, 3, 4],
                [5, 6, 7, 8, 9],
                [10, 11, 12, 13, 14],
                [-1, -1, 15, -1, -1]
            ];

            // Define main path and branches
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],  // Top row
                [1, 6], [2, 7], [3, 8],           // Vertical connections
                [5, 6], [6, 7], [7, 8], [8, 9],  // Middle row
                [6, 11], [7, 12], [8, 13],        // More verticals
                [10, 11], [11, 12], [12, 13], [13, 14], // Third row
                [12, 15]                          // Final room
            ];

            // Create room objects
            for (let i = 0; i < numRooms; i++) {
                // Find position in grid
                let row = 0, col = 0;
                for (let r = 0; r < grid.length; r++) {
                    const c = grid[r].indexOf(i);
                    if (c !== -1) {
                        row = r;
                        col = c;
                        break;
                    }
                }

                rooms.push({
                    id: i,
                    x: col * 80 + 40,
                    y: row * 60 + 40,
                    cleared: i === 0, // Start room is cleared
                    isStart: i === 0,
                    isFinal: i === 15,
                    isSpecial: false,
                    specialType: null,
                    connections: []
                });
            }

            // Add connections
            connections.forEach(([a, b]) => {
                if (rooms[a] && rooms[b]) {
                    rooms[a].connections.push(b);
                    rooms[b].connections.push(a);
                }
            });

            // Randomly select 1-3 special helper rooms (not start or final)
            const numSpecialRooms = Math.floor(Math.random() * 3) + 1;
            const availableForSpecial = rooms.filter(r => !r.isStart && !r.isFinal);
            const specialRooms = shuffle(availableForSpecial).slice(0, numSpecialRooms);
            
            const redCardTypes = ['jack', 'queen', 'king', 'ace'];
            specialRooms.forEach((room, idx) => {
                room.isSpecial = true;
                room.specialType = redCardTypes[idx % redCardTypes.length];
            });

            return rooms;
        }

        // Map Rendering
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        mapCanvas.width = 440;
        mapCanvas.height = 280;

        function drawDungeonMap() {
            if (!gameState.dungeonMap) return;

            mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

            const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
            const visibleRooms = new Set([gameState.currentRoomIndex]);
            
            // Add connected rooms to visible set (fog of war reveal)
            currentRoom.connections.forEach(connId => {
                visibleRooms.add(connId);
            });

            // Draw connections (corridors)
            gameState.dungeonMap.forEach(room => {
                room.connections.forEach(connId => {
                    if (connId > room.id) { // Draw each connection once
                        const connRoom = gameState.dungeonMap[connId];
                        
                        // Only draw if at least one room is visible or cleared
                        const visible = visibleRooms.has(room.id) || visibleRooms.has(connId) ||
                                      room.cleared || connRoom.cleared;
                        
                        if (visible) {
                            mapCtx.strokeStyle = (room.cleared && connRoom.cleared) ? 
                                'rgba(100, 100, 100, 0.6)' : 'rgba(212, 98, 31, 0.4)';
                            mapCtx.lineWidth = 3;
                            mapCtx.beginPath();
                            mapCtx.moveTo(room.x, room.y);
                            mapCtx.lineTo(connRoom.x, connRoom.y);
                            mapCtx.stroke();
                        }
                    }
                });
            });

            // Draw rooms
            gameState.dungeonMap.forEach((room, idx) => {
                const visible = visibleRooms.has(idx) || room.cleared;
                
                if (!visible && !room.cleared) return; // Don't draw if not visible

                mapCtx.save();

                // Determine room color/state
                let fillColor, strokeColor, glowColor;
                
                if (idx === gameState.currentRoomIndex) {
                    // Current room - gold glow
                    fillColor = 'rgba(212, 175, 55, 0.3)';
                    strokeColor = '#d4af37';
                    glowColor = '#d4af37';
                    
                    // Pulsing glow effect
                    const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    mapCtx.shadowBlur = 20 * pulse;
                    mapCtx.shadowColor = glowColor;
                } else if (room.cleared) {
                    // Cleared room - gray
                    fillColor = 'rgba(80, 80, 80, 0.5)';
                    strokeColor = 'rgba(150, 150, 150, 0.8)';
                } else if (room.isFinal && gameState.deck.length < 12) {
                    // Final room revealed when close
                    fillColor = 'rgba(139, 0, 0, 0.3)';
                    strokeColor = '#8b0000';
                    glowColor = '#ff0000';
                    mapCtx.shadowBlur = 15;
                    mapCtx.shadowColor = glowColor;
                } else if (visibleRooms.has(idx)) {
                    // Adjacent visible room - clickable
                    fillColor = 'rgba(42, 24, 16, 0.7)';
                    strokeColor = '#d4af37';
                } else {
                    // Fog of war
                    fillColor = 'rgba(20, 20, 20, 0.5)';
                    strokeColor = 'rgba(100, 100, 100, 0.5)';
                }

                // Draw room
                mapCtx.fillStyle = fillColor;
                mapCtx.strokeStyle = strokeColor;
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.arc(room.x, room.y, 12, 0, Math.PI * 2);
                mapCtx.fill();
                mapCtx.stroke();

                mapCtx.shadowBlur = 0;

                // Draw special markers
                if (room.isSpecial && (visible || room.cleared)) {
                    mapCtx.fillStyle = '#d4af37';
                    mapCtx.font = 'bold 16px Arial';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('★', room.x, room.y);
                } else if (room.isStart) {
                    mapCtx.fillStyle = '#00ff00';
                    mapCtx.font = 'bold 12px Arial';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('S', room.x, room.y);
                } else if (room.isFinal && (visible || gameState.deck.length < 12)) {
                    mapCtx.fillStyle = '#ff0000';
                    mapCtx.font = 'bold 12px Arial';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('B', room.x, room.y);
                }

                mapCtx.restore();
            });

            // Draw player token
            const playerRoom = gameState.dungeonMap[gameState.currentRoomIndex];
            mapCtx.fillStyle = '#ffffff';
            mapCtx.strokeStyle = '#000000';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.arc(playerRoom.x, playerRoom.y, 6, 0, Math.PI * 2);
            mapCtx.fill();
            mapCtx.stroke();
        }

        // Animate map updates
        function animateMapUpdate() {
            requestAnimationFrame(() => {
                drawDungeonMap();
            });
        }

        setInterval(animateMapUpdate, 50); // Update map for animations

        // Map click handler
        mapCanvas.addEventListener('click', (e) => {
            if (gameState.gameOver || gameState.cardsChosen < 3) return;

            const rect = mapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
            const visibleRooms = new Set(currentRoom.connections);

            // Check if clicked on an adjacent room
            gameState.dungeonMap.forEach((room, idx) => {
                if (visibleRooms.has(idx) && !room.cleared) {
                    const distance = Math.sqrt((x - room.x) ** 2 + (y - room.y) ** 2);
                    if (distance < 15) {
                        moveToRoom(idx);
                    }
                }
            });
        });

        function moveToRoom(roomIndex) {
            gameState.currentRoomIndex = roomIndex;
            const room = gameState.dungeonMap[roomIndex];
            
            showMessage(`Entering new chamber...`);
            
            // Check if special room
            if (room.isSpecial && !room.cleared) {
                setTimeout(() => showHelperEncounter(room), 500);
            } else {
                setTimeout(dealRoom, 800);
            }
            
            drawDungeonMap();
        }

        function showHelperEncounter(room) {
            const helpers = {
                jack: { 
                    title: 'The Mysterious Squire',
                    offers: () => {
                        const weapon = {
                            suit: '♦',
                            value: Math.floor(Math.random() * 5) + 2, // 2-6
                            type: 'weapon',
                            display: null,
                            name: null
                        };
                        weapon.display = getCardDisplay(weapon.value);
                        const weaponNames = { 2: 'Stick', 3: 'Dagger', 4: 'Short Sword', 5: 'Mace', 6: 'Battle Axe' };
                        weapon.name = weaponNames[weapon.value];
                        return [weapon];
                    }
                },
                queen: {
                    title: 'The Wandering Healer',
                    offers: () => {
                        const potion = {
                            suit: '♥',
                            value: Math.floor(Math.random() * 5) + 3, // 3-7
                            type: 'potion',
                            display: null,
                            name: null
                        };
                        potion.display = getCardDisplay(potion.value);
                        const potionNames = { 3: 'Minor Elixir', 4: 'Healing Brew', 5: 'Health Potion', 6: 'Greater Potion', 7: 'Vitality Draught' };
                        potion.name = potionNames[potion.value];
                        return [potion];
                    }
                },
                king: {
                    title: 'The Noble Merchant',
                    offers: () => {
                        const weapon = {
                            suit: '♦',
                            value: Math.floor(Math.random() * 5) + 3, // 3-7
                            type: 'weapon',
                            display: null,
                            name: null
                        };
                        weapon.display = getCardDisplay(weapon.value);
                        const weaponNames = { 3: 'Dagger', 4: 'Short Sword', 5: 'Mace', 6: 'Battle Axe', 7: 'Longsword' };
                        weapon.name = weaponNames[weapon.value];

                        const potion = {
                            suit: '♥',
                            value: Math.floor(Math.random() * 5) + 4, // 4-8
                            type: 'potion',
                            display: null,
                            name: null
                        };
                        potion.display = getCardDisplay(potion.value);
                        const potionNames = { 4: 'Healing Brew', 5: 'Health Potion', 6: 'Greater Potion', 7: 'Vitality Draught', 8: 'Major Elixir' };
                        potion.name = potionNames[potion.value];

                        return [weapon, potion];
                    }
                },
                ace: {
                    title: 'The Legendary Benefactor',
                    offers: () => {
                        const weapon = {
                            suit: '♦',
                            value: Math.floor(Math.random() * 3) + 7, // 7-9
                            type: 'weapon',
                            display: null,
                            name: null
                        };
                        weapon.display = getCardDisplay(weapon.value);
                        const weaponNames = { 7: 'Longsword', 8: 'War Hammer', 9: 'Greatsword' };
                        weapon.name = weaponNames[weapon.value];

                        const potion = {
                            suit: '♥',
                            value: Math.floor(Math.random() * 3) + 8, // 8-10
                            type: 'potion',
                            display: null,
                            name: null
                        };
                        potion.display = getCardDisplay(potion.value);
                        const potionNames = { 8: 'Major Elixir', 9: 'Superior Brew', 10: 'Legendary Potion' };
                        potion.name = potionNames[potion.value];

                        return [weapon, potion];
                    }
                }
            };

            const helper = helpers[room.specialType];
            const offerings = helper.offers();

            const modal = document.createElement('div');
            modal.className = 'helper-modal';
            
            let cardsHTML = '';
            offerings.forEach((item, idx) => {
                cardsHTML += `
                    <div class="helper-card">
                        <div class="card-suit" style="font-size: 2rem;">${item.suit}</div>
                        <div class="card-value" style="font-size: 1.5rem; margin: 0.5rem 0;">${item.display}</div>
                        <div style="font-size: 0.9rem; text-transform: capitalize;">${item.type}</div>
                        <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.3rem;">(${item.name})</div>
                        <button onclick="acceptHelper(${idx})" style="margin-top: 1rem; padding: 0.5rem 1rem; font-size: 0.9rem;">
                            Take ${item.type}
                        </button>
                    </div>
                `;
            });

            modal.innerHTML = `
                <div class="helper-modal-content">
                    <h3>${helper.title}</h3>
                    <p style="margin-bottom: 1rem; font-style: italic;">"I offer you aid in your quest, traveler..."</p>
                    <div class="helper-card-display">
                        ${cardsHTML}
                    </div>
                    <div class="helper-buttons">
                        <button onclick="declineHelper()">Decline Offer</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store offerings in a temporary variable for access
            window.currentOfferings = offerings;
        }

        window.acceptHelper = function(index) {
            const item = window.currentOfferings[index];
            
            if (item.type === 'weapon') {
                gameState.weapon = item;
                gameState.weaponLastMonster = Infinity;
                showMessage(`Accepted ${item.name}! Weapon equipped.`);
                createParticles(window.innerWidth / 2, window.innerHeight / 2, 30, '#d4af37', 'heal');
            } else if (item.type === 'potion') {
                const healAmount = Math.min(item.value, gameState.maxHealth - gameState.health);
                gameState.health = Math.min(gameState.maxHealth, gameState.health + item.value);
                gameState.potionsUsed++;
                showMessage(`Used ${item.name}! Restored ${healAmount} health.`);
                createParticles(window.innerWidth / 2, window.innerHeight / 2, 30, '#00ff00', 'heal');
            }
            
            document.querySelector('.helper-modal').remove();
            updateUI();
            setTimeout(dealRoom, 500);
        };

        window.declineHelper = function() {
            showMessage('Declined the offer. Proceeding into the room...');
            document.querySelector('.helper-modal').remove();
            setTimeout(dealRoom, 500);
        };

        // UI Updates
        function updateUI() {
            document.getElementById('health').textContent = gameState.health;
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = 
                `${Math.max(0, (gameState.health / gameState.maxHealth) * 100)}%`;
            
            // Pulse effect on health change
            healthBar.classList.add('pulse');
            setTimeout(() => healthBar.classList.remove('pulse'), 300);
            
            document.getElementById('deckCount').textContent = gameState.deck.length;
            document.getElementById('cardsChosen').textContent = `${gameState.cardsChosen} / 3`;
            document.getElementById('monstersSlain').textContent = gameState.monstersSlain;
            document.getElementById('roomsCleared').textContent = gameState.roomsCleared;
            document.getElementById('roomsAvoided').textContent = gameState.roomsAvoided;
            document.getElementById('potionCount').textContent = gameState.potionsUsed;

            // Update weapon display
            const weaponDisplay = document.getElementById('weaponDisplay');
            if (gameState.weapon) {
                weaponDisplay.innerHTML = `
                    <div class="card-inner">
                        <div class="card-suit">${gameState.weapon.suit}</div>
                        <div class="card-value">${gameState.weapon.display}</div>
                        <div class="card-type">Weapon</div>
                        <div style="font-size: 0.85rem; margin-top: 0.3rem; opacity: 0.8;">(${gameState.weapon.name})</div>
                        ${gameState.weaponLastMonster < Infinity ? 
                            `<div style="font-size: 0.8rem; margin-top: 0.5rem; opacity: 0.7;">
                                Max monster: ${gameState.weaponLastMonster}
                            </div>` : ''}
                    </div>
                `;
            } else {
                weaponDisplay.innerHTML = '<div style="text-align: center; opacity: 0.5;">No weapon</div>';
            }

            // Update avoid button
            document.getElementById('avoidBtn').disabled = 
                gameState.lastRoomAvoided || gameState.cardsChosen > 0 || gameState.room.length === 0;
        }

        function renderRoom() {
            const roomElement = document.getElementById('room');
            roomElement.innerHTML = '';

            gameState.room.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${card.type}`;
                
                if (gameState.cardsChosen >= 3) {
                    cardElement.classList.add('disabled');
                }

                cardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-suit">${card.suit}</div>
                        <div class="card-value">${card.display}</div>
                        <div class="card-type">${card.type.charAt(0).toUpperCase() + card.type.slice(1)}</div>
                        <div style="font-size: 0.85rem; margin-top: 0.3rem; opacity: 0.8;">(${card.name})</div>
                    </div>
                `;

                cardElement.onclick = () => chooseCard(index);
                roomElement.appendChild(cardElement);
            });
        }

        function showMessage(text, isError = false) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.style.borderColor = isError ? '#8b0000' : '#d4af37';
        }

        function showDamageIndicator(amount, x, y, isHeal = false) {
            const indicator = document.createElement('div');
            indicator.className = isHeal ? 'heal-indicator' : 'damage-indicator';
            indicator.textContent = isHeal ? `+${amount}` : `-${amount}`;
            indicator.style.left = x + 'px';
            indicator.style.top = y + 'px';
            document.body.appendChild(indicator);

            // Create particles
            if (isHeal) {
                createParticles(x, y, 20, '#00ff00', 'heal');
            } else {
                createParticles(x, y, 30, '#ff0000', 'blood');
                // Shake the screen on damage
                document.querySelector('.container').classList.add('shake');
                setTimeout(() => {
                    document.querySelector('.container').classList.remove('shake');
                }, 500);
            }

            setTimeout(() => indicator.remove(), 1000);
        }

        // Game logic
        function newGame() {
            gameState = {
                health: 20,
                maxHealth: 20,
                deck: createDeck(),
                room: [],
                cardsChosen: 0,
                weapon: null,
                weaponLastMonster: Infinity,
                lastRoomAvoided: false,
                potionUsedThisTurn: false,
                monstersSlain: 0,
                roomsCleared: 0,
                roomsAvoided: 0,
                potionsUsed: 0,
                gameOver: false,
                dungeonMap: generateDungeonMap(),
                currentRoomIndex: 0
            };

            document.getElementById('instructions').style.display = 'none';
            updateUI();
            drawDungeonMap();
            dealRoom();
            showMessage('A new adventure begins! Choose 3 of the 4 cards.');
        }

        function dealRoom() {
            // Keep the 4th card from previous room if exists
            const carryOver = gameState.room.length === 1 ? gameState.room[0] : null;
            gameState.room = carryOver ? [carryOver] : [];

            // Deal until we have 4 cards
            while (gameState.room.length < 4 && gameState.deck.length > 0) {
                gameState.room.push(gameState.deck.shift());
            }

            gameState.cardsChosen = 0;
            gameState.potionUsedThisTurn = false;

            if (gameState.deck.length === 0 && gameState.room.length < 4) {
                endGame();
                return;
            }

            renderRoom();
            updateUI();
            drawDungeonMap();
        }

        function chooseCard(index) {
            if (gameState.cardsChosen >= 3 || gameState.gameOver) return;

            const card = gameState.room[index];
            const cardElement = document.querySelectorAll('.card')[index];
            const rect = cardElement.getBoundingClientRect();

            // Add flip animation
            cardElement.classList.add('selected');

            // Handle card based on type
            switch (card.type) {
                case 'weapon':
                    handleWeapon(card);
                    // Golden sparkles for weapon
                    createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 15, '#d4af37', 'heal');
                    break;
                case 'potion':
                    handlePotion(card, rect.left + rect.width / 2, rect.top);
                    break;
                case 'monster':
                    handleMonster(card, rect.left + rect.width / 2, rect.top);
                    break;
            }

            // Remove card from room
            gameState.room.splice(index, 1);
            gameState.cardsChosen++;

            // Check if turn is complete
            if (gameState.cardsChosen >= 3) {
                setTimeout(() => {
                    if (gameState.health <= 0) {
                        endGame();
                    } else if (gameState.room.length === 1) {
                        gameState.roomsCleared++;
                        gameState.lastRoomAvoided = false;
                        
                        // Mark current room as cleared
                        gameState.dungeonMap[gameState.currentRoomIndex].cleared = true;
                        drawDungeonMap();
                        
                        // Check if there are adjacent uncleared rooms
                        const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
                        const hasAdjacentRooms = currentRoom.connections.some(connId => 
                            !gameState.dungeonMap[connId].cleared
                        );
                        
                        if (hasAdjacentRooms) {
                            showMessage('Room cleared! Click an adjacent room on the map to continue.');
                        } else {
                            // Auto-move if only one path (backtracking)
                            showMessage('Room cleared! Drawing new cards...');
                            setTimeout(dealRoom, 1000);
                        }
                    }
                }, 500);
            }

            renderRoom();
            updateUI();
        }

        function handleWeapon(card) {
            gameState.weapon = card;
            gameState.weaponLastMonster = Infinity;
            showMessage(`Equipped ${card.name} (${card.display}${card.suit} - ${card.value} damage)`);
        }

        function handlePotion(card, x, y) {
            if (gameState.potionUsedThisTurn) {
                showMessage(`Only one potion per turn! ${card.name} wasted.`);
                return;
            }

            const healAmount = Math.min(card.value, gameState.maxHealth - gameState.health);
            gameState.health = Math.min(gameState.maxHealth, gameState.health + card.value);
            gameState.potionUsedThisTurn = true;
            gameState.potionsUsed++;
            
            showDamageIndicator(healAmount, x, y, true);
            showMessage(`Drank ${card.name}! Restored ${healAmount} health.`);
        }

        function handleMonster(card, x, y) {
            let damage = card.value;
            let message = '';

            if (gameState.weapon && card.value <= gameState.weaponLastMonster) {
                // Use weapon
                damage = Math.max(0, card.value - gameState.weapon.value);
                gameState.weaponLastMonster = card.value;
                message = `Fought ${card.name} (${card.value}) with ${gameState.weapon.name}. `;
                
                if (damage > 0) {
                    message += `Took ${damage} damage!`;
                } else {
                    message += 'No damage taken!';
                }
            } else {
                // Fight barehanded
                message = `Fought ${card.name} barehanded! Took ${damage} damage!`;
            }

            gameState.health -= damage;
            gameState.monstersSlain++;

            if (damage > 0) {
                showDamageIndicator(damage, x, y, false);
            }

            showMessage(message);
        }

        function avoidRoom() {
            if (gameState.lastRoomAvoided || gameState.cardsChosen > 0) return;

            // Put all room cards at bottom of deck
            gameState.deck.push(...gameState.room);
            gameState.room = [];
            gameState.lastRoomAvoided = true;
            gameState.roomsAvoided++;

            showMessage('Room avoided! Cards sent to bottom of dungeon.');
            setTimeout(dealRoom, 1000);
        }

        function endGame() {
            gameState.gameOver = true;
            
            let score;
            let title;
            let message;

            if (gameState.health <= 0) {
                // Calculate negative score
                score = gameState.health;
                for (const card of gameState.deck) {
                    if (card.type === 'monster') {
                        score -= card.value;
                    }
                }
                title = '💀 DEFEAT 💀';
                message = 'You have fallen in the dungeon...';
            } else {
                // Victory!
                score = gameState.health;
                // Bonus for potion on last card
                if (gameState.room.length > 0 && gameState.room[0].type === 'potion' && 
                    gameState.health === gameState.maxHealth) {
                    score += gameState.room[0].value;
                }
                title = '🏆 VICTORY 🏆';
                message = 'You have conquered the dungeon!';
            }

            const gameOverEl = document.createElement('div');
            gameOverEl.className = 'game-over';
            gameOverEl.innerHTML = `
                <div class="game-over-content">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <div class="score">Score: ${score}</div>
                    <div style="margin-bottom: 1rem;">
                        <div>Monsters Slain: ${gameState.monstersSlain}</div>
                        <div>Rooms Cleared: ${gameState.roomsCleared}</div>
                        <div>Potions Used: ${gameState.potionsUsed}</div>
                    </div>
                    <button id="playAgainBtn">Play Again</button>
                </div>
            `;
            document.body.appendChild(gameOverEl);
            
            // Add event listener to play again button
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                location.reload();
            });
        }

        // Particle System
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        class Particle {
            constructor(x, y, color, type = 'damage') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = -Math.random() * 6 - 2;
                this.life = 1;
                this.decay = Math.random() * 0.015 + 0.015;
                this.size = Math.random() * 4 + 2;
                this.color = color;
                this.type = type;
                this.gravity = 0.15;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
                this.vx *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'heal') {
                    // Sparkle effect for healing
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (this.type === 'blood') {
                    // Blood splatter
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Default particle
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                }
                
                ctx.restore();
            }
        }

        let particles = [];

        function createParticles(x, y, count, color, type) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, type));
            }
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles = particles.filter(p => p.life > 0);
            
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            requestAnimationFrame(animateParticles);
        }

        animateParticles();

        // Ambient floating particles for atmosphere
        class AmbientParticle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.opacity = Math.random() * 0.3 + 0.1;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.x > canvas.width) this.x = 0;
                if (this.x < 0) this.x = canvas.width;
                if (this.y > canvas.height) this.y = 0;
                if (this.y < 0) this.y = canvas.height;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#d4af37';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        const ambientParticles = [];
        for (let i = 0; i < 50; i++) {
            ambientParticles.push(new AmbientParticle());
        }

        function animateAmbient() {
            ambientParticles.forEach(p => {
                p.update();
                p.draw();
            });
        }

        // Modify the animate loop to include ambient particles
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ambient particles
            ambientParticles.forEach(p => {
                p.update();
                p.draw();
            });
            
            // Draw effect particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            requestAnimationFrame(animate);
        }

        animate();

        // Initialize
        updateUI();

        // Add event listeners
        document.getElementById('newGameBtn').addEventListener('click', newGame);
        document.getElementById('avoidBtn').addEventListener('click', avoidRoom);
    </script>
</body>
</html>