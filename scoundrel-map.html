<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoundrel - A Rogue-like Card Game</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --parchment: #f4e8d0;
            --dark-wood: #2a1810;
            --burnt-orange: #d4621f;
            --blood-red: #8b0000;
            --gold: #d4af37;
            --shadow: rgba(0, 0, 0, 0.5);
            --card-bg: #1a1a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }

        body {
            font-family: 'Crimson Text', serif;
            background: linear-gradient(135deg, #1a0e08 0%, #2a1810 50%, #1a0e08 100%);
            background-attachment: fixed;
            color: var(--parchment);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, .03) 2px, rgba(0, 0, 0, .03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0, 0, 0, .03) 2px, rgba(0, 0, 0, .03) 4px);
            pointer-events: none;
            opacity: 0.3;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            font-weight: 700;
            color: var(--gold);
            text-shadow:
                2px 2px 0 var(--blood-red),
                4px 4px 8px var(--shadow);
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-style: italic;
            font-size: 1.2rem;
            color: var(--burnt-orange);
            opacity: 0.9;
        }

        .game-board {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 2rem;
            margin-bottom: 2rem;
            animation: fadeIn 1s ease-out 0.3s backwards;
        }

        .stats-panel {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.9), rgba(26, 14, 8, 0.9));
            border: 3px solid var(--burnt-orange);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px var(--shadow);
            backdrop-filter: blur(10px);
        }

        .stat-item {
            margin-bottom: 1.5rem;
        }

        .stat-label {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: var(--parchment);
            text-shadow: 0 2px 4px var(--shadow);
        }

        .health-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--burnt-orange);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            margin-top: 0.5rem;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--blood-red), var(--burnt-orange));
            transition: width 0.5s ease-out;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .weapon-display {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            min-height: 100px;
        }

        .weapon-card {
            position: relative;
        }

        .play-area {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.6), rgba(26, 14, 8, 0.6));
            border: 4px solid var(--burnt-orange);
            border-radius: 16px;
            padding: 2rem;
            min-height: 500px;
            box-shadow:
                0 8px 32px var(--shadow),
                inset 0 0 60px rgba(0, 0, 0, 0.3);
        }

        .room {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            aspect-ratio: 2.5/4;
            background: var(--card-bg);
            border: 3px solid var(--gold);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            transform-style: preserve-3d;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .card:hover:not(.disabled) {
            transform: translateY(-12px) scale(1.05);
            box-shadow:
                0 12px 24px var(--shadow),
                0 0 30px rgba(212, 175, 55, 0.4);
            border-color: var(--parchment);
        }

        .card.selected {
            animation: cardFlip 0.6s ease-out;
        }

        @keyframes cardFlip {
            0% {
                transform: rotateY(0deg) scale(1);
            }

            50% {
                transform: rotateY(90deg) scale(1.1);
            }

            100% {
                transform: rotateY(0deg) scale(1);
            }
        }

        .card.monster:hover:not(.disabled) {
            box-shadow:
                0 12px 24px var(--shadow),
                0 0 40px rgba(139, 0, 0, 0.6);
        }

        .card.weapon:hover:not(.disabled) {
            box-shadow:
                0 12px 24px var(--shadow),
                0 0 40px rgba(212, 175, 55, 0.6);
        }

        .card.potion:hover:not(.disabled) {
            box-shadow:
                0 12px 24px var(--shadow),
                0 0 40px rgba(0, 170, 0, 0.6);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-inner {
            width: 100%;
            height: 100%;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .card-suit {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .card-value {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 2px 4px var(--shadow);
        }

        .card-type {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        .card.monster {
            border-color: #8b0000;
            background: linear-gradient(145deg, #1a0000, #2a0a0a);
        }

        .card.weapon {
            border-color: #4a4a4a;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
        }

        .card.potion {
            border-color: #00aa00;
            background: linear-gradient(145deg, #002200, #003300);
        }

        .card-back {
            background: linear-gradient(145deg, var(--burnt-orange), var(--blood-red));
            border: 3px solid var(--gold);
            border-radius: 12px;
            aspect-ratio: 2.5/4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
            text-shadow: 0 2px 4px var(--shadow);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            padding: 1rem 2rem;
            background: linear-gradient(145deg, var(--burnt-orange), var(--blood-red));
            color: var(--parchment);
            border: 3px solid var(--gold);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            box-shadow: 0 4px 12px var(--shadow);
            font-weight: 600;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow);
            background: linear-gradient(145deg, var(--gold), var(--burnt-orange));
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .message {
            background: rgba(212, 175, 55, 0.1);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
            font-size: 1.1rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: messageSlide 0.3s ease-out;
        }

        .map-container {
            margin-top: 1.5rem;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--burnt-orange);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mapCanvas {
            border-radius: 4px;
            cursor: pointer;
        }

        .damage-indicator {
            position: fixed;
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--blood-red);
            text-shadow: 0 0 10px var(--blood-red);
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
        }

        .heal-indicator {
            position: fixed;
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            font-weight: 700;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            z-index: 1000;
            animation: damageFloat 1s ease-out forwards;
        }

        .monster-stack {
            position: absolute;
            top: 0;
            right: -10px;
            background: rgba(139, 0, 0, 0.9);
            border: 2px solid var(--blood-red);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.5);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .pulse {
            animation: pulse 0.3s ease-in-out;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.5s ease-out;
        }

        .game-over-content {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.95), rgba(26, 14, 8, 0.95));
            border: 4px solid var(--gold);
            border-radius: 16px;
            padding: 3rem;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 16px 48px var(--shadow);
        }

        .game-over-content h2 {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            color: var(--gold);
            margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px var(--shadow);
        }

        .helper-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            animation: fadeIn 0.3s ease-out;
        }

        .helper-modal-content {
            background: linear-gradient(145deg, rgba(42, 24, 16, 0.95), rgba(26, 14, 8, 0.95));
            border: 4px solid var(--gold);
            border-radius: 16px;
            padding: 2rem;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 16px 48px var(--shadow);
        }

        .helper-modal-content h3 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1rem;
        }

        .helper-card-display {
            margin: 1.5rem 0;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .helper-card {
            background: var(--card-bg);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 1.5rem;
            min-width: 150px;
        }

        .helper-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .score {
            font-size: 2rem;
            margin-bottom: 2rem;
            color: var(--parchment);
        }

        @media (max-width: 1024px) {
            .game-board {
                grid-template-columns: 1fr;
            }

            .room {
                grid-template-columns: repeat(2, 1fr);
            }

            h1 {
                font-size: 2.5rem;
            }
        }

        @media (max-height: 900px) {

            /* Adjustments for 1080p height (1920x1080) and similar */
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 3rem;
                margin-bottom: 1rem;
            }

            .subtitle {
                font-size: 1rem;
            }

            .game-board {
                gap: 1rem;
                margin-bottom: 1rem;
            }

            .stats-panel {
                padding: 1rem;
            }

            .stat-item {
                margin-bottom: 1rem;
            }

            .stat-label {
                font-size: 0.8rem;
                margin-bottom: 0.3rem;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .weapon-display {
                padding: 0.75rem;
                min-height: 80px;
            }

            .play-area {
                padding: 1.5rem;
                min-height: 400px;
            }

            .room {
                gap: 1rem;
                margin-bottom: 1.5rem;
            }

            .card {
                aspect-ratio: 2.5/3.8;
            }

            .card-suit {
                font-size: 2.5rem;
                margin-bottom: 0.3rem;
            }

            .card-value {
                font-size: 2rem;
            }

            .card-type {
                font-size: 0.8rem;
                margin-top: 0.3rem;
            }

            button {
                font-size: 1rem;
                padding: 0.75rem 1.5rem;
            }

            .message {
                padding: 0.75rem;
                font-size: 1rem;
                min-height: 50px;
            }

            .map-container {
                margin-top: 1rem;
                padding: 0.75rem;
            }

            #mapCanvas {
                max-width: 100%;
            }

            .instructions {
                padding: 1rem;
                margin-bottom: 1.5rem;
                font-size: 0.95rem;
                line-height: 1.5;
            }

            .instructions h3 {
                font-size: 1.2rem;
                margin-bottom: 0.75rem;
            }

            .instructions ul {
                margin-left: 1.25rem;
            }

            .instructions li {
                margin-bottom: 0.4rem;
            }
        }

        @media (max-height: 768px) {

            /* Further adjustments for 720p and smaller heights */
            .container {
                padding: 0.5rem;
            }

            header {
                margin-bottom: 1.5rem;
            }

            h1 {
                font-size: 2.5rem;
                margin-bottom: 0.5rem;
            }

            .subtitle {
                font-size: 0.9rem;
            }

            .game-board {
                gap: 0.75rem;
                margin-bottom: 0.75rem;
            }

            .stats-panel {
                padding: 0.75rem;
            }

            .stat-item {
                margin-bottom: 0.75rem;
            }

            .stat-label {
                font-size: 0.75rem;
            }

            .stat-value {
                font-size: 1.25rem;
            }

            .health-bar {
                height: 24px;
                margin-top: 0.3rem;
            }

            .weapon-display {
                padding: 0.5rem;
                min-height: 70px;
                font-size: 0.85rem;
            }

            .play-area {
                padding: 1rem;
                min-height: 350px;
            }

            .room {
                gap: 0.75rem;
                margin-bottom: 1rem;
            }

            .card {
                aspect-ratio: 2.5/3.6;
            }

            .card-suit {
                font-size: 2rem;
                margin-bottom: 0.25rem;
            }

            .card-value {
                font-size: 1.75rem;
            }

            .card-type {
                font-size: 0.75rem;
            }

            button {
                font-size: 0.9rem;
                padding: 0.6rem 1.25rem;
            }

            .controls {
                gap: 0.75rem;
            }

            .message {
                padding: 0.6rem;
                font-size: 0.95rem;
                min-height: 45px;
                margin-top: 0.75rem;
            }

            .map-container {
                margin-top: 0.75rem;
                padding: 0.5rem;
            }

            #mapCanvas {
                transform: scale(0.9);
                transform-origin: center;
            }

            .instructions {
                padding: 0.75rem;
                margin-bottom: 1rem;
                font-size: 0.9rem;
            }

            .instructions h3 {
                font-size: 1.1rem;
                margin-bottom: 0.5rem;
            }

            .instructions li {
                margin-bottom: 0.3rem;
            }

            .game-over-content,
            .helper-modal-content {
                padding: 2rem;
                max-width: 450px;
            }

            .game-over-content h2 {
                font-size: 2.5rem;
                margin-bottom: 1rem;
            }

            .helper-modal-content h3 {
                font-size: 1.75rem;
                margin-bottom: 0.75rem;
            }
        }

        @media (max-width: 768px) {

            /* Mobile portrait - for v2.0 but adding basic support */
            h1 {
                font-size: 2rem;
            }

            .game-board {
                grid-template-columns: 1fr;
            }

            .room {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }

            .card-suit {
                font-size: 1.75rem;
            }

            .card-value {
                font-size: 1.5rem;
            }

            #mapCanvas {
                width: 100%;
                height: auto;
            }
        }

        .instructions {
            background: rgba(42, 24, 16, 0.8);
            border: 2px solid var(--burnt-orange);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .instructions h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 1rem;
        }

        .instructions ul {
            margin-left: 1.5rem;
        }

        .instructions li {
            margin-bottom: 0.5rem;
        }

        .dungeon-info {
            font-size: 1rem;
            color: var(--burnt-orange);
            margin-top: 0.5rem;
        }
    </style>
</head>

<body>
    <canvas id="particleCanvas"></canvas>
    <div class="container">
        <header>
            <h1>âš” SCOUNDREL âš”</h1>
            <p class="subtitle">A Rogue-like Card Game</p>
        </header>

        <div class="instructions" id="instructions">
            <h3>How to Play:</h3>
            <ul>
                <li><strong>â™£â™  Monsters</strong> deal damage equal to their value (J=11, Q=12, K=13, A=14)</li>
                <li><strong>â™¦ Weapons</strong> reduce monster damage. Once used, can only fight weaker monsters</li>
                <li><strong>â™¥ Potions</strong> restore health (one per turn, max 20 HP)</li>
                <li>Choose 3 of 4 cards each turn. The 4th carries to next room</li>
                <li>You can skip a room, but not two in a row</li>
                <li>Survive the dungeon or die trying!</li>
            </ul>
        </div>

        <div class="game-board">
            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-label">Health</div>
                    <div class="stat-value" id="health">20</div>
                    <div class="health-bar">
                        <div class="health-fill" id="healthBar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Cards in Dungeon</div>
                    <div class="stat-value" id="deckCount">44</div>
                    <div class="dungeon-info">Start: 44 cards</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Potions Used</div>
                    <div class="stat-value" id="potionCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Rests Taken</div>
                    <div class="stat-value" id="restCount">0 / 3</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Equipped Weapon</div>
                    <div class="weapon-display" id="weaponDisplay">
                        <div style="text-align: center; opacity: 0.5;">No weapon</div>
                    </div>
                </div>
            </div>

            <div class="play-area">
                <div class="room" id="room"></div>
                <div class="controls">
                    <button id="avoidBtn">Avoid Room</button>
                    <button id="newGameBtn">New Game</button>
                </div>
                <div class="message" id="message">Click "New Game" to begin your descent into the dungeon...</div>
                <div class="map-container">
                    <canvas id="mapCanvas"></canvas>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-label">Cards Chosen</div>
                    <div class="stat-value" id="cardsChosen">0 / 3</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Monsters Slain</div>
                    <div class="stat-value" id="monstersSlain">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Rooms Cleared</div>
                    <div class="stat-value" id="roomsCleared">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Rooms Avoided</div>
                    <div class="stat-value" id="roomsAvoided">0</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            health: 20,
            maxHealth: 20,
            deck: [],
            room: [],
            cardsChosen: 0,
            weapon: null,
            weaponLastMonster: Infinity,
            lastRoomAvoided: false,
            potionUsedThisTurn: false,
            monstersSlain: 0,
            roomsCleared: 0,
            roomsAvoided: 0,
            potionsUsed: 0,
            gameOver: false,
            dungeonMap: null,
            currentRoomIndex: 0,
            playerPosition: null,
            redCardHelpers: [], // Store red face cards for helpers
            restRoomIndex: null, // Which room is the rest room
            restsUsed: 0, // How many times player has rested (max 3)
            justRested: false // True if just rested, prevents consecutive rests
        };

        // Card creation
        function createDeck() {
            const deck = [];
            const suits = {
                clubs: 'â™£',
                spades: 'â™ ',
                diamonds: 'â™¦',
                hearts: 'â™¥'
            };

            // Monster names by value
            const monsterNames = {
                2: 'Rat',
                3: 'Spider',
                4: 'Goblin',
                5: 'Skeleton',
                6: 'Orc',
                7: 'Warg',
                8: 'Troll',
                9: 'Wraith',
                10: 'Chimera',
                11: 'Dragon',
                12: 'Titan',
                13: 'Roc',
                14: 'Cyclops'
            };

            // Monsters: all clubs and spades
            ['clubs', 'spades'].forEach(suit => {
                for (let value = 2; value <= 14; value++) {
                    deck.push({
                        suit: suits[suit],
                        value: value,
                        type: 'monster',
                        display: getCardDisplay(value),
                        name: monsterNames[value]
                    });
                }
            });

            // Weapon names by value
            const weaponNames = {
                2: 'Stick',
                3: 'Dagger',
                4: 'Short Sword',
                5: 'Mace',
                6: 'Battle Axe',
                7: 'Longsword',
                8: 'War Hammer',
                9: 'Greatsword',
                10: 'Halberd'
            };

            // Weapons: diamonds 2-10
            for (let value = 2; value <= 10; value++) {
                deck.push({
                    suit: suits.diamonds,
                    value: value,
                    type: 'weapon',
                    display: getCardDisplay(value),
                    name: weaponNames[value]
                });
            }

            // Potion names by value
            const potionNames = {
                2: 'Weak Tonic',
                3: 'Minor Elixir',
                4: 'Healing Brew',
                5: 'Health Potion',
                6: 'Greater Potion',
                7: 'Vitality Draught',
                8: 'Major Elixir',
                9: 'Superior Brew',
                10: 'Legendary Potion'
            };

            // Potions: hearts 2-10
            for (let value = 2; value <= 10; value++) {
                deck.push({
                    suit: suits.hearts,
                    value: value,
                    type: 'potion',
                    display: getCardDisplay(value),
                    name: potionNames[value]
                });
            }

            return shuffle(deck);
        }

        function getCardDisplay(value) {
            const faces = { 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
            return faces[value] || value.toString();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Advanced Dungeon Map Generation
        function generateDungeonMap() {
            const rooms = [];
            const numRooms = 14; // Balanced for 44 card deck
            const cols = 5;
            const rows = 4;
            const cellWidth = 80;
            const cellHeight = 60;
            const paddingX = 40;
            const paddingY = 40;

            // Generate potential grid positions
            const grid = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    grid.push({ r, c });
                }
            }

            // Simple randomized spanning tree for guaranteed connectivity
            const shuffledGrid = shuffle(grid);
            const selectedPositions = shuffledGrid.slice(0, numRooms);

            // Ensure start and end are at reasonable positions
            // Start at top-left-ish, Boss at bottom-right-ish
            selectedPositions[0] = { r: 0, c: 0 };
            selectedPositions[numRooms - 1] = { r: rows - 1, c: cols - 1 };

            for (let i = 0; i < numRooms; i++) {
                const pos = selectedPositions[i];
                rooms.push({
                    id: i,
                    x: pos.c * cellWidth + paddingX + (Math.random() - 0.5) * 20,
                    y: pos.r * cellHeight + paddingY + (Math.random() - 0.5) * 20,
                    cleared: i === 0,
                    isStart: i === 0,
                    isFinal: i === numRooms - 1,
                    isSpecial: false,
                    specialType: null,
                    connections: [],
                    corridors: {} // Store corridor types: { targetId: 'long'|'short' }
                });
            }

            // Connect nearby rooms to form a graph
            for (let i = 0; i < numRooms; i++) {
                for (let j = i + 1; j < numRooms; j++) {
                    const dx = rooms[i].x - rooms[j].x;
                    const dy = rooms[i].y - rooms[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Connect if close enough
                    if (dist < 120 && rooms[i].connections.length < 3 && rooms[j].connections.length < 3) {
                        rooms[i].connections.push(j);
                        rooms[j].connections.push(i);
                        const type = dist > 90 ? 'long' : 'short';
                        rooms[i].corridors[j] = type;
                        rooms[j].corridors[i] = type;
                    }
                }
            }

            // Ensure every room has at least one connection
            rooms.forEach((room, i) => {
                if (room.connections.length === 0) {
                    const nearest = rooms.reduce((prev, curr, idx) => {
                        if (idx === i) return prev;
                        const dist = Math.sqrt((room.x - curr.x) ** 2 + (room.y - curr.y) ** 2);
                        const prevDist = Math.sqrt((room.x - rooms[prev].x) ** 2 + (room.y - rooms[prev].y) ** 2);
                        return dist < prevDist ? idx : prev;
                    }, i === 0 ? 1 : 0);
                    room.connections.push(nearest);
                    rooms[nearest].connections.push(i);
                    room.corridors[nearest] = 'long';
                    rooms[nearest].corridors[i] = 'long';
                }
            });

            // Select one final boss room (last room generated)
            rooms[numRooms - 1].isFinal = true;

            // Select special helper rooms
            const numSpecialRooms = Math.floor(Math.random() * 3) + 2;
            const availableForSpecial = rooms.filter(r => !r.isStart && !r.isFinal);
            const specialRooms = shuffle(availableForSpecial).slice(0, numSpecialRooms);
            const redCardTypes = ['jack', 'queen', 'king', 'ace'];
            specialRooms.forEach((room, idx) => {
                room.isSpecial = true;
                room.specialType = redCardTypes[idx % redCardTypes.length];
            });

            // Select 1-2 rest rooms
            const availableForRest = rooms.filter(r => !r.isStart && !r.isFinal && !r.isSpecial);
            const numRestRooms = Math.floor(Math.random() * 2) + 1;
            const restRooms = shuffle(availableForRest).slice(0, numRestRooms);
            restRooms.forEach(room => {
                room.isRestRoom = true;
                room.restsUsed = 0;
            });

            return rooms;
        }

        // --- NEW: Map State for Animations ---
        let mapAnimation = {
            playerX: 0,
            playerY: 0,
            targetX: 0,
            targetY: 0,
            isMoving: false,
            torchRadius: 80
        };

        // Map Rendering
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');

        // Make canvas responsive
        function resizeMapCanvas() {
            const container = mapCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            const maxWidth = Math.min(440, rect.width - 32); // 32px for padding
            const maxHeight = Math.min(280, window.innerHeight * 0.25); // Max 25% of viewport height

            mapCanvas.width = maxWidth;
            mapCanvas.height = maxHeight;

            drawDungeonMap();
        }

        resizeMapCanvas();
        window.addEventListener('resize', resizeMapCanvas);

        function drawDungeonMap() {
            if (!gameState.dungeonMap) return;

            mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

            const scaleX = mapCanvas.width / 440;
            const scaleY = mapCanvas.height / 280;
            const scale = Math.min(scaleX, scaleY);

            // Update player animated position
            if (mapAnimation.isMoving) {
                const dx = mapAnimation.targetX - mapAnimation.playerX;
                const dy = mapAnimation.targetY - mapAnimation.playerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 1) {
                    mapAnimation.playerX = mapAnimation.targetX;
                    mapAnimation.playerY = mapAnimation.targetY;
                    mapAnimation.isMoving = false;
                } else {
                    mapAnimation.playerX += dx * 0.1;
                    mapAnimation.playerY += dy * 0.1;
                }
            } else {
                const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
                mapAnimation.playerX = currentRoom.x;
                mapAnimation.playerY = currentRoom.y;
            }

            const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
            const visibleRooms = new Set([gameState.currentRoomIndex]);
            currentRoom.connections.forEach(connId => visibleRooms.add(connId));

            // Background Parchment Texture (Simulated)
            mapCtx.fillStyle = '#2a1810';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

            // Draw grid lines for aesthetic
            mapCtx.strokeStyle = 'rgba(212, 175, 55, 0.05)';
            mapCtx.lineWidth = 1;
            for (let x = 0; x < mapCanvas.width; x += 40 * scale) {
                mapCtx.beginPath(); mapCtx.moveTo(x, 0); mapCtx.lineTo(x, mapCanvas.height); mapCtx.stroke();
            }
            for (let y = 0; y < mapCanvas.height; y += 40 * scale) {
                mapCtx.beginPath(); mapCtx.moveTo(0, y); mapCtx.lineTo(mapCanvas.width, y); mapCtx.stroke();
            }

            // Draw corridors
            gameState.dungeonMap.forEach(room => {
                room.connections.forEach(connId => {
                    if (connId > room.id) {
                        const connRoom = gameState.dungeonMap[connId];
                        const visible = visibleRooms.has(room.id) || visibleRooms.has(connId) ||
                            room.cleared || connRoom.cleared;

                        if (visible) {
                            const type = room.corridors[connId] || 'short';
                            mapCtx.save();
                            mapCtx.setLineDash(type === 'long' ? [10, 5] : []);
                            mapCtx.strokeStyle = (room.cleared && connRoom.cleared) ?
                                'rgba(100, 100, 100, 0.4)' : 'rgba(212, 98, 31, 0.6)';
                            mapCtx.lineWidth = (type === 'long' ? 4 : 6) * scale;

                            // "Hand-drawn" effect - double line
                            mapCtx.beginPath();
                            mapCtx.moveTo(room.x * scale, room.y * scale);
                            mapCtx.lineTo(connRoom.x * scale, connRoom.y * scale);
                            mapCtx.stroke();

                            mapCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                            mapCtx.lineWidth = 2 * scale;
                            mapCtx.stroke();
                            mapCtx.restore();
                        }
                    }
                });
            });

            // Draw rooms
            gameState.dungeonMap.forEach((room, idx) => {
                const visible = visibleRooms.has(idx) || room.cleared;
                if (!visible && !room.cleared) return;

                const isCurrent = idx === gameState.currentRoomIndex;
                const isAdjacent = currentRoom.connections.includes(idx);

                mapCtx.save();

                // Room shape (Rectangle for rooms)
                const size = 20 * scale;
                mapCtx.translate(room.x * scale, room.y * scale);

                let roomColor = '#1a0e08';
                let borderColor = '#d4621f';

                if (isCurrent) {
                    borderColor = '#d4af37';
                    mapCtx.shadowBlur = 15 * scale;
                    mapCtx.shadowColor = '#d4af37';
                } else if (room.cleared) {
                    borderColor = '#555';
                    roomColor = '#222';
                } else if (isAdjacent) {
                    borderColor = '#d4af37';
                }

                mapCtx.fillStyle = roomColor;
                mapCtx.strokeStyle = borderColor;
                mapCtx.lineWidth = 3 * scale;
                mapCtx.lineJoin = 'round';

                mapCtx.beginPath();
                mapCtx.rect(-size / 2, -size / 2, size, size);
                mapCtx.fill();
                mapCtx.stroke();

                // Room Icons
                mapCtx.shadowBlur = 0;
                mapCtx.fillStyle = borderColor;
                mapCtx.font = `${12 * scale}px Arial`;
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';

                if (room.isStart) mapCtx.fillText('S', 0, 0);
                else if (room.isFinal) mapCtx.fillText('â˜ ', 0, 0);
                else if (room.isRestRoom && room.cleared) mapCtx.fillText('ðŸ”¥', 0, 0);
                else if (room.isSpecial && (visible || room.cleared) && !room.cleared) mapCtx.fillText('?', 0, 0);

                mapCtx.restore();
            });

            // Torchlight Effect (Radial Gradient with Wobble)
            const torchX = mapAnimation.playerX * scale;
            const torchY = mapAnimation.playerY * scale;

            // Subtle flickering wobble
            const wobble = Math.sin(Date.now() / 150) * 2 * scale;
            const radiusWobble = Math.sin(Date.now() / 100) * 5 * scale;
            const torchRadius = (150 + radiusWobble) * scale;

            mapCtx.save();
            const grad = mapCtx.createRadialGradient(
                torchX + wobble, torchY + wobble,
                20 * scale,
                torchX + wobble, torchY + wobble,
                torchRadius
            );
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.6, 'rgba(0,0,0,0.3)');
            grad.addColorStop(1, 'rgba(0,0,0,0.85)');

            mapCtx.fillStyle = grad;
            mapCtx.globalCompositeOperation = 'source-over';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            mapCtx.restore();

            // Player Token
            mapCtx.save();
            mapCtx.fillStyle = '#fff';
            mapCtx.shadowBlur = 10 * scale;
            mapCtx.shadowColor = '#fff';
            mapCtx.beginPath();
            mapCtx.arc(mapAnimation.playerX * scale, mapAnimation.playerY * scale, 6 * scale, 0, Math.PI * 2);
            mapCtx.fill();
            mapCtx.restore();
        }

        // Animate map updates
        function animateMap() {
            drawDungeonMap();
            requestAnimationFrame(animateMap);
        }
        animateMap();

        // Map click handler
        mapCanvas.addEventListener('click', (e) => {
            if (gameState.gameOver) return;

            // Allow clicking if: (1) room is cleared (3 cards chosen) OR (2) room was avoided
            const canMove = gameState.cardsChosen >= 3 || gameState.room.length === 0;
            if (!canMove) return;

            const rect = mapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Account for canvas scaling
            const scaleX = mapCanvas.width / 440;
            const scaleY = mapCanvas.height / 280;
            const scale = Math.min(scaleX, scaleY);

            const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
            const connectedRooms = new Set(currentRoom.connections);

            // Check if clicked on any connected room (cleared or not)
            gameState.dungeonMap.forEach((room, idx) => {
                if (connectedRooms.has(idx)) {
                    const roomX = room.x * scale;
                    const roomY = room.y * scale;
                    const distance = Math.sqrt((x - roomX) ** 2 + (y - roomY) ** 2);
                    if (distance < 15 * scale) {
                        moveToRoom(idx);
                    }
                }
            });
        });

        function moveToRoom(roomIndex) {
            const oldRoomIndex = gameState.currentRoomIndex;
            const oldRoom = gameState.dungeonMap[oldRoomIndex];

            // If leaving an avoided room (no cards dealt yet), mark it as uncleared
            if (gameState.room.length === 0 && gameState.cardsChosen === 0 && !oldRoom.isStart) {
                oldRoom.cleared = false;
            }

            gameState.currentRoomIndex = roomIndex;
            const room = gameState.dungeonMap[roomIndex];

            // Start movement animation
            mapAnimation.targetX = room.x;
            mapAnimation.targetY = room.y;
            mapAnimation.isMoving = true;

            // Reset avoid flag when moving to new room
            gameState.lastRoomAvoided = false;

            // Check if this is a cleared rest room (bonfire)
            if (room.isRestRoom && room.cleared && !gameState.justRested && gameState.restsUsed < 3) {
                setTimeout(() => showRestModal(room), 600);
                return;
            }

            // If room is already cleared, just move there and let player choose next room
            if (room.cleared) {
                showMessage(`Passing through cleared chamber... Choose your next path.`);
                drawDungeonMap();
                return;
            }

            // Entering a new room means player is no longer "just rested"
            gameState.justRested = false;

            showMessage(`Entering new chamber...`);

            // Check if special room
            if (room.isSpecial) {
                setTimeout(() => showHelperEncounter(room), 500);
            } else {
                setTimeout(dealRoom, 800);
            }

            drawDungeonMap();
        }

        function showHelperEncounter(room) {
            const helpers = {
                jack: {
                    title: 'The Mysterious Squire',
                    offers: () => {
                        const weapon = {
                            suit: 'â™¦',
                            value: Math.floor(Math.random() * 5) + 2, // 2-6
                            type: 'weapon',
                            display: null,
                            name: null
                        };
                        weapon.display = getCardDisplay(weapon.value);
                        const weaponNames = { 2: 'Stick', 3: 'Dagger', 4: 'Short Sword', 5: 'Mace', 6: 'Battle Axe' };
                        weapon.name = weaponNames[weapon.value];
                        return [weapon];
                    }
                },
                queen: {
                    title: 'The Wandering Healer',
                    offers: () => {
                        const potion = {
                            suit: 'â™¥',
                            value: Math.floor(Math.random() * 5) + 3, // 3-7
                            type: 'potion',
                            display: null,
                            name: null
                        };
                        potion.display = getCardDisplay(potion.value);
                        const potionNames = { 3: 'Minor Elixir', 4: 'Healing Brew', 5: 'Health Potion', 6: 'Greater Potion', 7: 'Vitality Draught' };
                        potion.name = potionNames[potion.value];
                        return [potion];
                    }
                },
                king: {
                    title: 'The Noble Merchant',
                    offers: () => {
                        const weapon = {
                            suit: 'â™¦',
                            value: Math.floor(Math.random() * 5) + 3, // 3-7
                            type: 'weapon',
                            display: null,
                            name: null
                        };
                        weapon.display = getCardDisplay(weapon.value);
                        const weaponNames = { 3: 'Dagger', 4: 'Short Sword', 5: 'Mace', 6: 'Battle Axe', 7: 'Longsword' };
                        weapon.name = weaponNames[weapon.value];

                        const potion = {
                            suit: 'â™¥',
                            value: Math.floor(Math.random() * 5) + 4, // 4-8
                            type: 'potion',
                            display: null,
                            name: null
                        };
                        potion.display = getCardDisplay(potion.value);
                        const potionNames = { 4: 'Healing Brew', 5: 'Health Potion', 6: 'Greater Potion', 7: 'Vitality Draught', 8: 'Major Elixir' };
                        potion.name = potionNames[potion.value];

                        return [weapon, potion];
                    }
                },
                ace: {
                    title: 'The Legendary Benefactor',
                    offers: () => {
                        const weapon = {
                            suit: 'â™¦',
                            value: Math.floor(Math.random() * 3) + 7, // 7-9
                            type: 'weapon',
                            display: null,
                            name: null
                        };
                        weapon.display = getCardDisplay(weapon.value);
                        const weaponNames = { 7: 'Longsword', 8: 'War Hammer', 9: 'Greatsword' };
                        weapon.name = weaponNames[weapon.value];

                        const potion = {
                            suit: 'â™¥',
                            value: Math.floor(Math.random() * 3) + 8, // 8-10
                            type: 'potion',
                            display: null,
                            name: null
                        };
                        potion.display = getCardDisplay(potion.value);
                        const potionNames = { 8: 'Major Elixir', 9: 'Superior Brew', 10: 'Legendary Potion' };
                        potion.name = potionNames[potion.value];

                        return [weapon, potion];
                    }
                }
            };

            const helper = helpers[room.specialType];
            const offerings = helper.offers();

            const modal = document.createElement('div');
            modal.className = 'helper-modal';

            let cardsHTML = '';
            offerings.forEach((item, idx) => {
                cardsHTML += `
                    <div class="helper-card">
                        <div class="card-suit" style="font-size: 2rem;">${item.suit}</div>
                        <div class="card-value" style="font-size: 1.5rem; margin: 0.5rem 0;">${item.display}</div>
                        <div style="font-size: 0.9rem; text-transform: capitalize;">${item.type}</div>
                        <div style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.3rem;">(${item.name})</div>
                        <button onclick="acceptHelper(${idx})" style="margin-top: 1rem; padding: 0.5rem 1rem; font-size: 0.9rem;">
                            Take ${item.type}
                        </button>
                    </div>
                `;
            });

            modal.innerHTML = `
                <div class="helper-modal-content">
                    <h3>${helper.title}</h3>
                    <p style="margin-bottom: 1rem; font-style: italic;">"I offer you aid in your quest, traveler..."</p>
                    <div class="helper-card-display">
                        ${cardsHTML}
                    </div>
                    <div class="helper-buttons">
                        <button onclick="declineHelper()">Decline Offer</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Store offerings in a temporary variable for access
            window.currentOfferings = offerings;
        }

        window.acceptHelper = function (index) {
            const item = window.currentOfferings[index];

            if (item.type === 'weapon') {
                gameState.weapon = item;
                gameState.weaponLastMonster = Infinity;
                showMessage(`Accepted ${item.name}! Weapon equipped.`);
                createParticles(window.innerWidth / 2, window.innerHeight / 2, 30, '#d4af37', 'heal');
            } else if (item.type === 'potion') {
                const healAmount = Math.min(item.value, gameState.maxHealth - gameState.health);
                gameState.health = Math.min(gameState.maxHealth, gameState.health + item.value);
                gameState.potionsUsed++;
                showMessage(`Used ${item.name}! Restored ${healAmount} health.`);
                createParticles(window.innerWidth / 2, window.innerHeight / 2, 30, '#00ff00', 'heal');
            }

            document.querySelector('.helper-modal').remove();
            updateUI();
            setTimeout(dealRoom, 500);
        };

        window.declineHelper = function () {
            showMessage('Declined the offer. Proceeding into the room...');
            document.querySelector('.helper-modal').remove();
            setTimeout(dealRoom, 500);
        };

        function showRestModal(room) {
            const restsRemaining = 3 - gameState.restsUsed;

            const modal = document.createElement('div');
            modal.className = 'helper-modal';

            modal.innerHTML = `
                <div class="helper-modal-content">
                    <h3>ðŸ”¥ Bonfire Chamber ðŸ”¥</h3>
                    <p style="margin-bottom: 1rem; font-style: italic;">
                        "A warm fire crackles in the hearth. You may rest here to recover your strength."
                    </p>
                    <div style="margin: 1.5rem 0; font-size: 1.2rem;">
                        <div>Restore: <span style="color: #00ff00; font-weight: bold;">+5 HP</span></div>
                        <div style="margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.8;">
                            Rests remaining: ${restsRemaining}
                        </div>
                    </div>
                    <div class="helper-buttons">
                        <button onclick="acceptRest()">Rest at Bonfire</button>
                        <button onclick="declineRest()">Continue On</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        window.acceptRest = function () {
            const oldHealth = gameState.health;
            gameState.health = Math.min(gameState.maxHealth, gameState.health + 5);
            const healAmount = gameState.health - oldHealth;
            gameState.restsUsed++;
            gameState.justRested = true; // Prevent consecutive rests

            showMessage(`Rested at the bonfire! Restored ${healAmount} HP. Choose your next path.`);
            createParticles(window.innerWidth / 2, window.innerHeight / 2, 40, '#ff6600', 'heal');

            document.querySelector('.helper-modal').remove();
            updateUI();
            drawDungeonMap();
        };

        window.declineRest = function () {
            showMessage('You press onward without resting. Choose your next path.');
            document.querySelector('.helper-modal').remove();
            drawDungeonMap();
        };

        // UI Updates
        function updateUI() {
            document.getElementById('health').textContent = gameState.health;
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width =
                `${Math.max(0, (gameState.health / gameState.maxHealth) * 100)}%`;

            // Pulse effect on health change
            healthBar.classList.add('pulse');
            setTimeout(() => healthBar.classList.remove('pulse'), 300);

            document.getElementById('deckCount').textContent = gameState.deck.length;
            document.getElementById('cardsChosen').textContent = `${gameState.cardsChosen} / 3`;
            document.getElementById('monstersSlain').textContent = gameState.monstersSlain;
            document.getElementById('roomsCleared').textContent = gameState.roomsCleared;
            document.getElementById('roomsAvoided').textContent = gameState.roomsAvoided;
            document.getElementById('potionCount').textContent = gameState.potionsUsed;
            document.getElementById('restCount').textContent = `${gameState.restsUsed} / 3`;

            // Update weapon display
            const weaponDisplay = document.getElementById('weaponDisplay');
            if (gameState.weapon) {
                weaponDisplay.innerHTML = `
                    <div class="card-inner">
                        <div class="card-suit">${gameState.weapon.suit}</div>
                        <div class="card-value">${gameState.weapon.display}</div>
                        <div class="card-type">Weapon</div>
                        <div style="font-size: 0.85rem; margin-top: 0.3rem; opacity: 0.8;">(${gameState.weapon.name})</div>
                        ${gameState.weaponLastMonster < Infinity ?
                        `<div style="font-size: 0.8rem; margin-top: 0.5rem; opacity: 0.7;">
                                Max monster: ${gameState.weaponLastMonster}
                            </div>` : ''}
                    </div>
                `;
            } else {
                weaponDisplay.innerHTML = '<div style="text-align: center; opacity: 0.5;">No weapon</div>';
            }

            // Update avoid button
            document.getElementById('avoidBtn').disabled =
                gameState.lastRoomAvoided || gameState.cardsChosen > 0 || gameState.room.length === 0;
        }

        function renderRoom() {
            const roomElement = document.getElementById('room');
            roomElement.innerHTML = '';

            gameState.room.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = `card ${card.type}`;

                if (gameState.cardsChosen >= 3) {
                    cardElement.classList.add('disabled');
                }

                cardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-suit">${card.suit}</div>
                        <div class="card-value">${card.display}</div>
                        <div class="card-type">${card.type.charAt(0).toUpperCase() + card.type.slice(1)}</div>
                        <div style="font-size: 0.85rem; margin-top: 0.3rem; opacity: 0.8;">(${card.name})</div>
                    </div>
                `;

                cardElement.onclick = () => chooseCard(index);
                roomElement.appendChild(cardElement);
            });
        }

        function showMessage(text, isError = false) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.style.borderColor = isError ? '#8b0000' : '#d4af37';
        }

        function showDamageIndicator(amount, x, y, isHeal = false) {
            const indicator = document.createElement('div');
            indicator.className = isHeal ? 'heal-indicator' : 'damage-indicator';
            indicator.textContent = isHeal ? `+${amount}` : `-${amount}`;
            indicator.style.left = x + 'px';
            indicator.style.top = y + 'px';
            document.body.appendChild(indicator);

            // Create particles
            if (isHeal) {
                createParticles(x, y, 20, '#00ff00', 'heal');
            } else {
                createParticles(x, y, 30, '#ff0000', 'blood');
                // Shake the screen on damage
                document.querySelector('.container').classList.add('shake');
                setTimeout(() => {
                    document.querySelector('.container').classList.remove('shake');
                }, 500);
            }

            setTimeout(() => indicator.remove(), 1000);
        }

        // Game logic
        function newGame() {
            gameState = {
                health: 20,
                maxHealth: 20,
                deck: createDeck(),
                room: [],
                cardsChosen: 0,
                weapon: null,
                weaponLastMonster: Infinity,
                lastRoomAvoided: false,
                potionUsedThisTurn: false,
                monstersSlain: 0,
                roomsCleared: 0,
                roomsAvoided: 0,
                potionsUsed: 0,
                gameOver: false,
                dungeonMap: generateDungeonMap(),
                currentRoomIndex: 0,
                restsUsed: 0,
                justRested: false
            };

            // Initialize player animated position
            const startRoom = gameState.dungeonMap[0];
            mapAnimation.playerX = startRoom.x;
            mapAnimation.playerY = startRoom.y;
            mapAnimation.targetX = startRoom.x;
            mapAnimation.targetY = startRoom.y;
            mapAnimation.isMoving = false;

            document.getElementById('instructions').style.display = 'none';
            updateUI();
            drawDungeonMap();
            dealRoom();
            showMessage('A new adventure begins! Choose 3 of the 4 cards.');
        }

        function dealRoom() {
            // Don't deal if we already have a full room
            if (gameState.room.length >= 4) {
                console.log('Room already has cards, skipping deal');
                return;
            }

            // Keep the 4th card from previous room if exists
            const carryOver = gameState.room.length === 1 ? gameState.room[0] : null;
            gameState.room = carryOver ? [carryOver] : [];

            // Deal until we have 4 cards
            while (gameState.room.length < 4 && gameState.deck.length > 0) {
                gameState.room.push(gameState.deck.shift());
            }

            gameState.cardsChosen = 0;
            gameState.potionUsedThisTurn = false;

            if (gameState.deck.length === 0 && gameState.room.length < 4) {
                endGame();
                return;
            }

            renderRoom();
            updateUI();
            drawDungeonMap();
        }

        function chooseCard(index) {
            if (gameState.cardsChosen >= 3 || gameState.gameOver) return;

            const card = gameState.room[index];
            const cardElement = document.querySelectorAll('.card')[index];
            const rect = cardElement.getBoundingClientRect();

            // Add flip animation
            cardElement.classList.add('selected');

            // Handle card based on type
            switch (card.type) {
                case 'weapon':
                    handleWeapon(card);
                    // Golden sparkles for weapon
                    createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, 15, '#d4af37', 'heal');
                    break;
                case 'potion':
                    handlePotion(card, rect.left + rect.width / 2, rect.top);
                    break;
                case 'monster':
                    handleMonster(card, rect.left + rect.width / 2, rect.top);

                    // CRITICAL: Check for death immediately after monster damage
                    if (gameState.health <= 0) {
                        gameState.gameOver = true;
                        // Remove card from room before ending
                        gameState.room.splice(index, 1);
                        renderRoom();
                        updateUI();
                        // Small delay so player sees the damage
                        setTimeout(() => endGame(), 1000);
                        return;
                    }
                    break;
            }

            // Remove card from room
            gameState.room.splice(index, 1);
            gameState.cardsChosen++;

            // Check if turn is complete
            if (gameState.cardsChosen >= 3) {
                setTimeout(() => {
                    if (gameState.health <= 0) {
                        endGame();
                    } else if (gameState.room.length === 1) {
                        gameState.roomsCleared++;
                        gameState.lastRoomAvoided = false;

                        // Mark current room as cleared
                        gameState.dungeonMap[gameState.currentRoomIndex].cleared = true;

                        // Entering and clearing a new room means no longer "just rested"
                        gameState.justRested = false;

                        drawDungeonMap();

                        // Check if there are adjacent uncleared rooms
                        const currentRoom = gameState.dungeonMap[gameState.currentRoomIndex];
                        const hasAdjacentRooms = currentRoom.connections.some(connId =>
                            !gameState.dungeonMap[connId].cleared
                        );

                        if (hasAdjacentRooms || currentRoom.connections.length > 0) {
                            showMessage('Room cleared! Click an adjacent room on the map to continue.');
                        } else {
                            // No adjacent rooms available
                            showMessage('Room cleared! No more paths available.');
                        }
                    }
                }, 500);
            }

            renderRoom();
            updateUI();
        }

        function handleWeapon(card) {
            gameState.weapon = card;
            gameState.weaponLastMonster = Infinity;
            showMessage(`Equipped ${card.name} (${card.display}${card.suit} - ${card.value} damage)`);
        }

        function handlePotion(card, x, y) {
            if (gameState.potionUsedThisTurn) {
                showMessage(`Only one potion per turn! ${card.name} wasted.`);
                return;
            }

            const oldHealth = gameState.health;
            gameState.health = Math.min(gameState.maxHealth, gameState.health + card.value);
            const healAmount = gameState.health - oldHealth;
            gameState.potionUsedThisTurn = true;
            gameState.potionsUsed++;

            if (healAmount > 0) {
                showDamageIndicator(healAmount, x, y, true);
                showMessage(`Drank ${card.name}! Restored ${healAmount} health.`);
            } else {
                showMessage(`Drank ${card.name}! Already at full health.`);
            }
        }

        function handleMonster(card, x, y) {
            let damage = card.value;
            let message = '';

            if (gameState.weapon && card.value <= gameState.weaponLastMonster) {
                // Use weapon
                damage = Math.max(0, card.value - gameState.weapon.value);
                gameState.weaponLastMonster = card.value;
                message = `Fought ${card.name} (${card.value}) with ${gameState.weapon.name}. `;

                if (damage > 0) {
                    message += `Took ${damage} damage!`;
                } else {
                    message += 'No damage taken!';
                }
            } else {
                // Fight barehanded
                message = `Fought ${card.name} barehanded! Took ${damage} damage!`;
            }

            gameState.health -= damage;
            gameState.monstersSlain++;

            if (damage > 0) {
                showDamageIndicator(damage, x, y, false);
            }

            showMessage(message);
        }

        function avoidRoom() {
            if (gameState.lastRoomAvoided || gameState.cardsChosen > 0) return;

            // Put all room cards at bottom of deck
            gameState.deck.push(...gameState.room);
            gameState.room = [];
            gameState.lastRoomAvoided = true;
            gameState.roomsAvoided++;

            // Mark current room as "cleared" so player can backtrack
            gameState.dungeonMap[gameState.currentRoomIndex].cleared = true;

            showMessage('Room avoided! Click an adjacent room on the map to backtrack.');
            drawDungeonMap();
        }

        function endGame() {
            gameState.gameOver = true;

            let score;
            let title;
            let message;

            if (gameState.health <= 0) {
                // Calculate negative score
                score = gameState.health;
                for (const card of gameState.deck) {
                    if (card.type === 'monster') {
                        score -= card.value;
                    }
                }
                title = 'ðŸ’€ DEFEAT ðŸ’€';
                message = 'You have fallen in the dungeon...';
            } else {
                // Victory!
                score = gameState.health;
                // Bonus for potion on last card
                if (gameState.room.length > 0 && gameState.room[0].type === 'potion' &&
                    gameState.health === gameState.maxHealth) {
                    score += gameState.room[0].value;
                }
                title = 'ðŸ† VICTORY ðŸ†';
                message = 'You have conquered the dungeon!';
            }

            const gameOverEl = document.createElement('div');
            gameOverEl.className = 'game-over';
            gameOverEl.innerHTML = `
                <div class="game-over-content">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    <div class="score">Score: ${score}</div>
                    <div style="margin-bottom: 1rem;">
                        <div>Monsters Slain: ${gameState.monstersSlain}</div>
                        <div>Rooms Cleared: ${gameState.roomsCleared}</div>
                        <div>Potions Used: ${gameState.potionsUsed}</div>
                        <div>Rests Taken: ${gameState.restsUsed}</div>
                    </div>
                    <button id="playAgainBtn">Play Again</button>
                </div>
            `;
            document.body.appendChild(gameOverEl);

            // Add event listener to play again button
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                location.reload();
            });
        }

        // Particle System
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        class Particle {
            constructor(x, y, color, type = 'damage') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = -Math.random() * 6 - 2;
                this.life = 1;
                this.decay = Math.random() * 0.015 + 0.015;
                this.size = Math.random() * 4 + 2;
                this.color = color;
                this.type = type;
                this.gravity = 0.15;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
                this.vx *= 0.98;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;

                if (this.type === 'heal') {
                    // Sparkle effect for healing
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size + 2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (this.type === 'blood') {
                    // Blood splatter
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Default particle
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                }

                ctx.restore();
            }
        }

        let particles = [];

        function createParticles(x, y, count, color, type) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, type));
            }
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            particles = particles.filter(p => p.life > 0);

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            requestAnimationFrame(animateParticles);
        }

        animateParticles();

        // Ambient floating particles for atmosphere
        class AmbientParticle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.opacity = Math.random() * 0.3 + 0.1;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.x > canvas.width) this.x = 0;
                if (this.x < 0) this.x = canvas.width;
                if (this.y > canvas.height) this.y = 0;
                if (this.y < 0) this.y = canvas.height;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#d4af37';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        const ambientParticles = [];
        for (let i = 0; i < 50; i++) {
            ambientParticles.push(new AmbientParticle());
        }

        function animateAmbient() {
            ambientParticles.forEach(p => {
                p.update();
                p.draw();
            });
        }

        // Modify the animate loop to include ambient particles
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw ambient particles
            ambientParticles.forEach(p => {
                p.update();
                p.draw();
            });

            // Draw effect particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            requestAnimationFrame(animate);
        }

        animate();

        // Initialize
        updateUI();

        // Add event listeners
        document.getElementById('newGameBtn').addEventListener('click', newGame);
        document.getElementById('avoidBtn').addEventListener('click', avoidRoom);
    </script>
</body>

</html>