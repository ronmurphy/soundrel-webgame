<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCOUNDREL - PHANTOM EDITION</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;700;900&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --p5-red: #D31111;
            --p5-black: #000000;
            --p5-white: #FFFFFF;
            --p5-grey: #222222;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Montserrat', sans-serif;
        }

        body {
            background-color: var(--p5-black);
            color: var(--p5-white);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* --- Background Effects --- */
        .bg-skew {
            position: fixed;
            top: 0;
            left: 0;
            width: 150%;
            height: 150%;
            background: linear-gradient(45deg, var(--p5-red) 25%, transparent 25%),
                linear-gradient(-45deg, var(--p5-red) 25%, transparent 25%);
            background-size: 100px 100px;
            opacity: 0.1;
            z-index: -1;
            transform: rotate(-15deg) translate(-10%, -10%);
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 1000;
        }

        /* --- Layout --- */
        .app-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: 100px 1fr 120px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            background: var(--p5-red);
            transform: skewX(-10deg);
            box-shadow: 10px 10px 0 var(--p5-white);
        }

        h1 {
            font-family: 'Bebas Neue', cursive;
            font-size: 4rem;
            color: var(--p5-black);
            transform: skewX(10deg);
            letter-spacing: 4px;
        }

        /* --- Sidebar Stats --- */
        .sidebar {
            background: rgba(255, 255, 255, 0.05);
            border-left: 8px solid var(--p5-red);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transform: skewY(-2deg);
        }

        .stat-block {
            background: var(--p5-black);
            padding: 15px;
            border: 2px solid var(--p5-white);
            position: relative;
            transform: skewX(-5deg);
        }

        .stat-label {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: var(--p5-red);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 900;
            text-align: right;
        }

        .health-bar-container {
            height: 20px;
            background: #333;
            margin-top: 10px;
            border: 1px solid var(--p5-white);
        }

        .health-bar-fill {
            height: 100%;
            background: var(--p5-red);
            transition: width 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }

        .health-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: glitch 2s infinite;
        }

        @keyframes glitch {
            0% {
                transform: translateX(-100%);
            }

            20% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        /* --- Main Map Area --- */
        .main-content {
            position: relative;
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid var(--p5-white);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        canvas#mapCanvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* --- Footer Controls --- */
        footer {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            padding: 10px;
        }

        .p5-btn {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            padding: 10px 40px;
            background: var(--p5-white);
            color: var(--p5-black);
            border: none;
            cursor: pointer;
            transform: skewX(-15deg);
            transition: all 0.2s;
            box-shadow: 8px 8px 0 var(--p5-red);
            text-transform: uppercase;
        }

        .p5-btn:hover {
            background: var(--p5-red);
            color: var(--p5-white);
            transform: skewX(-15deg) translate(-4px, -4px);
            box-shadow: 12px 12px 0 var(--p5-white);
        }

        .p5-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        /* --- Encounter Modal --- */
        #encounterModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .encounter-bg {
            position: absolute;
            width: 150%;
            height: 400px;
            background: var(--p5-red);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-10deg);
            z-index: -1;
            animation: stripeSlide 10s linear infinite;
        }

        @keyframes stripeSlide {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 500px 0;
            }
        }

        .battle-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 6rem;
            color: var(--p5-white);
            text-shadow: 8px 8px 0 var(--p5-red);
            margin-bottom: 50px;
            z-index: 10;
        }

        .card-spread {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 400px;
            width: 90%;
            perspective: 1000px;
        }

        .p5-card {
            width: 200px;
            height: 320px;
            background: var(--p5-white);
            border: 10px solid var(--p5-black);
            margin: 0 -30px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: bottom center;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .p5-card:hover {
            z-index: 100 !important;
            transform: translateY(-50px) scale(1.1) !important;
            border-color: var(--p5-red);
        }

        .p5-card.monster {
            background: var(--p5-black);
            color: var(--p5-white);
            border-color: var(--p5-red);
        }

        .p5-card.weapon {
            background: #333;
            color: var(--p5-white);
            border-color: var(--p5-white);
        }

        .p5-card.potion {
            background: var(--p5-white);
            color: var(--p5-black);
            border-color: #008800;
        }

        .p5-card .suit {
            font-size: 3rem;
            font-weight: 900;
        }

        .p5-card .val {
            font-family: 'Bebas Neue', cursive;
            font-size: 5rem;
            line-height: 1;
        }

        .p5-card .name {
            font-weight: 700;
            text-transform: uppercase;
            margin-top: auto;
            border-top: 2px solid;
            padding-top: 5px;
        }

        /* Card rotations for the fan effect */
        .card-spread .p5-card:nth-child(1) {
            transform: rotate(-15deg) translateY(30px);
            z-index: 1;
            animation-delay: 0.1s;
        }

        .card-spread .p5-card:nth-child(2) {
            transform: rotate(-5deg) translateY(0);
            z-index: 2;
            animation-delay: 0.2s;
        }

        .card-spread .p5-card:nth-child(3) {
            transform: rotate(5deg) translateY(0);
            z-index: 3;
            animation-delay: 0.3s;
        }

        .card-spread .p5-card:nth-child(4) {
            transform: rotate(15deg) translateY(30px);
            z-index: 4;
            animation-delay: 0.4s;
        }

        .battle-controls {
            margin-top: 50px;
            display: flex;
            gap: 20px;
        }

        .message-box {
            position: absolute;
            bottom: 40px;
            right: 40px;
            background: var(--p5-white);
            color: var(--p5-black);
            padding: 20px;
            width: 400px;
            border-left: 10px solid var(--p5-red);
            font-weight: 700;
            transform: skewX(-5deg);
            box-shadow: 10px 10px 0 var(--p5-black);
            animation: slideIn 0.3s ease-out;
            z-index: 100;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%) skewX(-5deg);
                opacity: 0;
            }

            to {
                transform: translateX(0) skewX(-5deg);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="bg-skew"></div>
    <div class="scanlines"></div>

    <div class="app-container">
        <header>
            <h1>SCOUNDREL // PHANTOM</h1>
            <div id="deckInfo" style="font-family:'Bebas Neue'; font-size: 2rem; color: #fff;">DECK: 44</div>
        </header>

        <aside class="sidebar">
            <div class="stat-block">
                <div class="stat-label">Protagonist HP</div>
                <div class="stat-value" id="healthVal">20</div>
                <div class="health-bar-container">
                    <div class="health-bar-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>

            <div class="stat-block">
                <div class="stat-label">Weapon Equipped</div>
                <div id="weaponInfo" style="font-weight:900; font-size: 1.2rem;">NONE</div>
                <div id="weaponLimit" style="font-size: 0.8rem; opacity: 0.7;">NO LIMIT</div>
            </div>

            <div class="stat-block">
                <div class="stat-label">Dungeon Stats</div>
                <div style="font-size: 0.9rem;">
                    Monsters Slain: <span id="slainCount">0</span><br>
                    Floors Explored: <span id="floorCount">0</span><br>
                    Rests Memory: <span id="restCount">0 / 3</span>
                </div>
            </div>

            <div
                style="margin-top: auto; background: var(--p5-red); color: #000; padding: 10px; font-weight: 900; transform: skewX(-10deg);">
                MISSION STATUS: ACTIVE
            </div>
        </aside>

        <main class="main-content">
            <canvas id="mapCanvas"></canvas>
            <div id="gameMessage" class="message-box">Entering the Metaverse... Prepare yourself.</div>
        </main>

        <footer>
            <button class="p5-btn" id="newGameBtn">Infiltration Start</button>
            <button class="p5-btn" id="avoidBtn" disabled>Tactical Retreat</button>
        </footer>
    </div>

    <!-- Encounter UI -->
    <div id="encounterModal">
        <div class="encounter-bg"></div>
        <h2 class="battle-title">SHADOW ENCOUNTER!</h2>
        <div class="card-spread" id="cardSpread">
            <!-- Cards will be injected here -->
        </div>
        <div class="battle-controls">
            <button class="p5-btn" id="closeBattleBtn" style="display:none">Return to Map</button>
        </div>
    </div>

    <script>
        // --- GAME LOGIC ENGINE ---
        let state = {
            hp: 20,
            maxHp: 20,
            deck: [],
            weapon: null,
            weaponLastVal: Infinity,
            rooms: [],
            currentRoomIdx: 0,
            potionsUsedThisTurn: false,
            slain: 0,
            floors: 0,
            rests: 0,
            lastRoomAvoided: false,
            activeEncounter: {
                cards: [],
                chosenCount: 0,
                isOpen: false
            }
        };

        const SUITS = {
            CLUBS: '♣',
            SPADES: '♠',
            DIAMONDS: '♦',
            HEARTS: '♥'
        };

        function createDeck() {
            let deck = [];

            // Monsters (C/S 2-14)
            [SUITS.CLUBS, SUITS.SPADES].forEach(suit => {
                for (let v = 2; v <= 14; v++) {
                    deck.push({ suit, val: v, type: 'monster', name: getMonsterName(v) });
                }
            });

            // Weapons (D 2-10)
            for (let v = 2; v <= 10; v++) {
                deck.push({ suit: SUITS.DIAMONDS, val: v, type: 'weapon', name: getWeaponName(v) });
            }

            // Potions (H 2-10)
            for (let v = 2; v <= 10; v++) {
                deck.push({ suit: SUITS.HEARTS, val: v, type: 'potion', name: getPotionName(v) });
            }

            return shuffle(deck);
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getMonsterName(v) {
            const names = { 11: 'Jack', 12: 'Queen', 13: 'King', 14: 'Ace' };
            return names[v] || v;
        }
        function getWeaponName(v) { return `Blade lv.${v}`; }
        function getPotionName(v) { return `HP Incense ${v}`; }

        // --- MAP GENERATION (Fixed Persistence) ---
        function generateMap() {
            const rooms = [];
            const numRooms = 14;
            const cols = 5;
            const rows = 3;

            // Create discrete room objects
            for (let i = 0; i < numRooms; i++) {
                rooms.push({
                    id: i,
                    x: (i % cols) * 150 + 100 + (Math.random() * 40),
                    y: Math.floor(i / cols) * 120 + 100 + (Math.random() * 40),
                    state: i === 0 ? 'cleared' : 'uncleared', // uncleared, cleared, avoided
                    cards: [], // Cards currently in this room
                    isBoss: i === numRooms - 1,
                    connections: []
                });
            }

            // Connect linearly + some branches
            for (let i = 0; i < numRooms - 1; i++) {
                rooms[i].connections.push(i + 1);
                rooms[i + 1].connections.push(i);

                // Random cross-branch
                if (Math.random() > 0.7 && i + 3 < numRooms) {
                    rooms[i].connections.push(i + 3);
                    rooms[i + 3].connections.push(i);
                }
            }
            return rooms;
        }

        // --- RENDERING & UI ---
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Lines
            ctx.strokeStyle = '#D31111';
            ctx.lineWidth = 2;
            state.rooms.forEach(r => {
                r.connections.forEach(cid => {
                    const target = state.rooms[cid];
                    ctx.beginPath();
                    ctx.moveTo(r.x, r.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                });
            });

            // Rooms
            state.rooms.forEach((r, idx) => {
                const isCurrent = idx === state.currentRoomIdx;
                const isAdjacent = state.rooms[state.currentRoomIdx].connections.includes(idx);

                ctx.save();
                ctx.translate(r.x, r.y);
                ctx.rotate(-0.1);

                // Room Box
                ctx.fillStyle = r.state === 'cleared' ? '#333' : (r.state === 'avoided' ? '#D31111' : '#fff');
                if (isCurrent) ctx.shadowBlur = 20; ctx.shadowColor = '#D31111';

                ctx.fillRect(-15, -15, 30, 30);
                ctx.strokeStyle = '#000';
                ctx.strokeRect(-15, -15, 30, 30);

                if (isAdjacent || r.state !== 'uncleared') {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 12px Montserrat';
                    ctx.textAlign = 'center';
                    if (r.isBoss) ctx.fillText('BOSS', 0, 5);
                    else if (r.state === 'avoided') {
                        ctx.fillStyle = '#fff';
                        ctx.fillText('SKIP', 0, 5);
                    }
                }

                ctx.restore();
            });

            // Player Icon
            const p = state.rooms[state.currentRoomIdx];
            ctx.fillStyle = '#D31111';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function updateStats() {
            document.getElementById('healthVal').innerText = state.hp;
            document.getElementById('healthBar').style.width = `${(state.hp / state.maxHp) * 100}%`;
            document.getElementById('deckInfo').innerText = `DECK: ${state.deck.length}`;
            document.getElementById('slainCount').innerText = state.slain;
            document.getElementById('floorCount').innerText = state.floors;
            document.getElementById('restCount').innerText = `${state.rests} / 3`;

            const weaponInfo = document.getElementById('weaponInfo');
            const weaponLimit = document.getElementById('weaponLimit');
            if (state.weapon) {
                weaponInfo.innerText = `${state.weapon.name} (${state.weapon.val})`;
                weaponLimit.innerText = state.weaponLastVal === Infinity ? "NO LIMIT" : `MAX MONSTER: ${state.weaponLastVal}`;
                weaponInfo.style.color = 'var(--p5-red)';
            } else {
                weaponInfo.innerText = "BARE HANDS";
                weaponLimit.innerText = "FULL DAMAGE TAKEN";
                weaponInfo.style.color = '#fff';
            }

            // Buttons
            document.getElementById('avoidBtn').disabled =
                state.lastRoomAvoided ||
                state.activeEncounter.chosenCount > 0 ||
                !state.activeEncounter.isOpen;
        }

        function showMessage(msg) {
            document.getElementById('gameMessage').innerText = msg;
        }

        // --- GAME ACTIONS ---
        function startNewGame() {
            state.hp = 20;
            state.deck = createDeck();
            state.weapon = null;
            state.weaponLastVal = Infinity;
            state.rooms = generateMap();
            state.currentRoomIdx = 0;
            state.slain = 0;
            state.floors = 0;
            state.rests = 0;
            state.lastRoomAvoided = false;

            updateStats();
            drawMap();
            triggerEncounter();
        }

        function triggerEncounter() {
            const room = state.rooms[state.currentRoomIdx];
            if (room.state === 'cleared') {
                showMessage("Room is clear. Choose your next path.");
                return;
            }

            // Populate room cards if empty (new encounter)
            if (room.cards.length === 0) {
                const carryCard = room.carryCard;
                room.cards = carryCard ? [carryCard] : [];
                while (room.cards.length < 4 && state.deck.length > 0) {
                    room.cards.push(state.deck.shift());
                }
            }

            state.activeEncounter = {
                cards: room.cards,
                chosenCount: 0,
                isOpen: true
            };

            renderEncounter();
            document.getElementById('encounterModal').style.display = 'flex';
            updateStats();
        }

        function renderEncounter() {
            const spread = document.getElementById('cardSpread');
            spread.innerHTML = '';

            state.activeEncounter.cards.forEach((card, idx) => {
                const cardEl = document.createElement('div');
                cardEl.className = `p5-card ${card.type}`;
                cardEl.style.zIndex = idx;

                cardEl.innerHTML = `
                    <div class="suit">${card.suit}</div>
                    <div class="val">${getDisplayVal(card.val)}</div>
                    <div class="name">${card.name}</div>
                `;

                cardEl.onclick = () => resolveCard(idx);
                spread.appendChild(cardEl);
            });
        }

        function getDisplayVal(v) {
            if (v === 11) return 'J';
            if (v === 12) return 'Q';
            if (v === 13) return 'K';
            if (v === 14) return 'A';
            return v;
        }

        function resolveCard(idx) {
            if (state.activeEncounter.chosenCount >= 3) return;

            const card = state.activeEncounter.cards[idx];

            switch (card.type) {
                case 'weapon':
                    state.weapon = card;
                    state.weaponLastVal = Infinity;
                    showMessage(`Equipped ${card.name}!`);
                    break;
                case 'potion':
                    if (state.potionsUsedThisTurn) {
                        showMessage("Already used a potion this turn. Discarded.");
                    } else {
                        const heal = Math.min(card.val, state.maxHp - state.hp);
                        state.hp += heal;
                        state.potionsUsedThisTurn = true;
                        showMessage(`Healed for ${heal} HP.`);
                    }
                    break;
                case 'monster':
                    let damage = card.val;
                    if (state.weapon && card.val <= state.weaponLastVal) {
                        damage = Math.max(0, card.val - state.weapon.val);
                        state.weaponLastVal = card.val;
                        showMessage(`Defeated ${card.name}! Took ${damage} DMG using Blade.`);
                    } else {
                        showMessage(`Fought ${card.name} barehanded! Took ${damage} DMG.`);
                    }
                    state.hp -= damage;
                    state.slain++;
                    break;
            }

            state.activeEncounter.cards.splice(idx, 1);
            state.activeEncounter.chosenCount++;

            if (state.hp <= 0) {
                gameOver();
                return;
            }

            if (state.activeEncounter.chosenCount === 3) {
                finishEncounter();
            } else {
                renderEncounter();
            }
            updateStats();
        }

        function finishEncounter() {
            const room = state.rooms[state.currentRoomIdx];
            room.state = 'cleared';
            room.carryCard = state.activeEncounter.cards[0]; // Carry 4th card
            room.cards = [];
            state.activeEncounter.isOpen = false;
            state.potionsUsedThisTurn = false;
            state.floors++;
            state.lastRoomAvoided = false;

            document.getElementById('closeBattleBtn').style.display = 'block';
            showMessage("Encounter Finished! Return to map.");
        }

        function avoidRoom() {
            const room = state.rooms[state.currentRoomIdx];
            // Put cards at bottom of deck
            state.deck.push(...room.cards);
            room.cards = [];
            room.state = 'avoided';
            state.lastRoomAvoided = true;

            document.getElementById('encounterModal').style.display = 'none';
            showMessage("Tactical Retreat Successful. Choose a new path.");
            drawMap();
            updateStats();
        }

        function gameOver() {
            document.getElementById('encounterModal').style.background = '#D31111';
            document.querySelector('.battle-title').innerText = "Wasted...";
            document.getElementById('cardSpread').innerHTML = `<div style="font-size:3rem; font-weight:900;">GAME OVER</div>`;
            document.getElementById('closeBattleBtn').style.display = 'block';
            document.getElementById('closeBattleBtn').innerText = "Retry Infiltration";
            document.getElementById('closeBattleBtn').onclick = () => location.reload();
        }

        // --- MAP NAVIGATION ---
        canvas.onclick = (e) => {
            if (state.activeEncounter.isOpen) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            state.rooms.forEach((r, idx) => {
                const dist = Math.sqrt((r.x - x) ** 2 + (r.y - y) ** 2);
                if (dist < 20) {
                    const current = state.rooms[state.currentRoomIdx];
                    if (current.connections.includes(idx)) {
                        state.currentRoomIdx = idx;
                        drawMap();
                        triggerEncounter();
                    }
                }
            });
        };

        // --- LISTENERS ---
        document.getElementById('newGameBtn').onclick = startNewGame;
        document.getElementById('avoidBtn').onclick = avoidRoom;
        document.getElementById('closeBattleBtn').onclick = () => {
            document.getElementById('encounterModal').style.display = 'none';
            document.getElementById('closeBattleBtn').style.display = 'none';
            drawMap();
        };

        // Init
        drawMap();
    </script>
</body>

</html>